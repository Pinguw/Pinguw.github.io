{"meta":{"title":"Pinguw's Blog","subtitle":"","description":"","author":"Pinguw","url":"http://example.com","root":"/"},"pages":[{"title":"关于博主","date":"2024-04-21T13:18:41.054Z","updated":"2024-04-21T13:18:41.054Z","comments":true,"path":"aboutme.html","permalink":"http://example.com/aboutme.html","excerpt":"","text":"小时候打喷嚏，总觉得是谁在偷偷想自己。现在看来，说不定是长大的自己在想念小时候的自己。 2023年8月 - 刚得知自己考上大学就稀里糊涂地被拉去打了新生赛。（那时候的我还不知道自己已经踏上了一条不归路） 2023年10月 - 新生赛的征程结束，大家都各自选好了自己的方向，即使到现在我也不知为何会选择在逆向上走下去。我队已经3年没人做逆向了，不妨把这算作一条理由罢。 2023年11月 - 首次参加企业比赛HWS，虽然最后的奖金只有300米，但也是一次极棒的体验和学习经历。 2024年3月 - 我大抵是完全放弃了深造下去的念头。唉，但是谁不想读研啊，我也想学习啊。。。 2024年4月13日 - 校赛，其中五道逆向，斩获四道一血，一道二血，算是不负众望吧。 2024年4月 - Pinguw加入HASHTEAM！！！ 2024年4月17日 - 跟着其他队员首次接触到AWD模式，然鹅只有挨打的份。说实话，即使是什么也不会（只能改个弱口令），也能真切地感受到这个比赛模式的紧张与刺激。也是，AWD里，逆向手又能做什么呢？ 2024年4月21日 - 成功加入山东大学镜像站，负责后端开发。第一个任务是…五一前把现在的后端看完。"},{"title":"赞助我","date":"2024-04-14T07:57:37.833Z","updated":"2024-04-14T07:57:37.833Z","comments":true,"path":"donate.html","permalink":"http://example.com/donate.html","excerpt":"","text":"不必赞助我了，把钱留给自己和父母吧，学会爱自己，也要记得，及时报养育之恩。"},{"title":"我的朋友","date":"2024-04-14T10:02:41.213Z","updated":"2024-04-14T10:02:41.213Z","comments":true,"path":"friends.html","permalink":"http://example.com/friends.html","excerpt":"","text":"我们会慢慢长大成人，随着季节的不停变换路边盛开的鲜花也在不断变化，那个季节盛开的鲜花到底叫什么名字，轻轻摇曳着一旦触摸它就会轻轻地被扎到，用鼻子靠近闻一闻，会有一股淡淡的青涩太阳的芳香，随着那股香味慢慢变淡我们也在长大成人，但是那朵花一定会在某处继续盛开。 朋友们每次编译时，随机排序"},{"title":"文章归档","date":"2024-04-11T13:54:27.378Z","updated":"2024-04-11T13:54:27.378Z","comments":true,"path":"archives.html","permalink":"http://example.com/archives.html","excerpt":"","text":""},{"title":"","date":"2024-04-21T11:31:07.246Z","updated":"2024-04-21T11:31:07.246Z","comments":true,"path":"diary/essay.html","permalink":"http://example.com/diary/essay.html","excerpt":"","text":"2024-4-15“一次错过不算错误，错在来不及看清楚你的面目我就交出全部”——周深《春雪》 2024-4-16有一个喜欢的人真的太重要了，在你打算稀里糊涂过这普普通通的一生的时候，会因为对方而再想努力一下，在那么多疲惫不堪甚至抬不起头的日子，会因为对方而觉得人生还有盼头。 ——村上春树 2024-4-18四月开满蓝花楹，满城尽是紫花香。 蓝花楹的花语是：“在绝望中等待爱情，你来或不来它都在枝头绽放，在绝望中永恒等待”。 但是，不要等待爱情来拯救绝望的自己。 2024-4-20上船不思岸上人，下船不提船上事，旧人无需知近况，新人不必思过往。 人生聚散本事常事，一念执着万般皆苦，一念放下便是重生。 往者不可谏，来者犹可追 2024-4-21花和人都会遇到各种各样的不幸，但生命的长河是无止境的。 我一直认为，两个人之间最亲密的事不是牵手亲嘴，而是在对方面前掉眼泪。 人，一旦心寒了，就再也不会对你长篇大论了，言语会变得剪短，目光会变得冷淡。除了沉默，就是冷漠。"}],"posts":[{"title":"敲响天堂之门","slug":"Reverse/Gate-of-Heaven","date":"2024-04-11T14:33:51.000Z","updated":"2024-04-20T07:59:06.805Z","comments":true,"path":"2024/04/11/Reverse/Gate-of-Heaven/","permalink":"http://example.com/2024/04/11/Reverse/Gate-of-Heaven/","excerpt":"","text":"“天堂之门”介绍：天堂之门技术（Heaven’s Gate）是依靠操作系统提供的在不同位数CPU进行跨架构的指令调用（SysWoW64），这使得32位和64位的指令环境可以放在同一个程序中，但是目前的调试器包括IDA在内很少有能跨架构调试的，这使得IDA的反汇编和调试都不能正常进行。 一个在动态调试层面恐怕是最有难度的逆向反调试 架构之间的切换：首先我们要知道32位寄存器cs的值是0x22，64位cs寄存器的值是0x33，我们将cs的值在这两者间切换，便达到了跨架构运行程序的目的。 那么我们如何更改寄存器cs的值呢？我们知道，mov指令是无法直接改变cs寄存器的值的，需要借助 call和 retf来实现cs段的切换 call far和retf(ret far)是可以同时改变cs和ip的： 1234push 0x33 ;0x33作为cs的新值call $+5 ;下一条指令的地址入栈add dword [esp], 5 ;+5后即是指向retf的下一条指令retf ;跳转到下一条指令，同时pop is和pop cs 或者： 1jmp far 33:地址 这样就实现了将cs改为0x33的功能，即从32位跳转到64位。 对应的从64位跳转到32位的指令是： 1234call $+5mov dword [rsp + 4], 0x23add dword [rsp], 0xDretf so，对cs的更改可以让程序在32位和64之间切换。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;malloc.h&gt;int main()&#123; _asm &#123; _emit 0x6A // push 0x33 _emit 0x33 _emit 0xE8 // call $+5 _emit 0x05 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x83 // add dword [esp], 5 _emit 0x04 _emit 0x24 _emit 0x05 _emit 0xCB // retf &#125; printf(&quot;进入64位\\n&quot;); _asm &#123; _emit 0xE8 // call $+5 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0xC7 // mov dword [rsp + 4], 0x23 _emit 0x44 _emit 0x24 _emit 0x04 _emit 0x23 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x83 // add dword [rsp], 0xD _emit 0x04 _emit 0x24 _emit 0x0D _emit 0xCB // retf &#125; printf(&quot;回到32位\\n&quot;); return 0;&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"http://example.com/categories/Reverse/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"}]},{"title":"MRCTF2020 VirtualTree（花指令+动态调试）","slug":"Reverse/VirtualTree","date":"2024-04-10T14:27:36.000Z","updated":"2024-04-11T13:11:36.569Z","comments":true,"path":"2024/04/10/Reverse/VirtualTree/","permalink":"http://example.com/2024/04/10/Reverse/VirtualTree/","excerpt":"","text":"[MRCTF2020]VirtualTree（花指令+动态调试）32位无壳，放进IDA里，main函数很清晰， 试着恢复一下符号表： 看一下key的调用，找到更改key值的函数， 结合题目，可以看出这是一个二叉树，搞一个结构体： 回头看第一个加密函数： 就是把key中的数据根input一个一个异或，比较简单， 把input搞成0，动调可以搞到key的数据 1key = &quot;MLGPOKFCJENIHDBA&quot; 再分析enc2:，有花指令，比较容易去掉： 去掉后里面的加密函数是这样： 逆向这个函数解密后发现根本解不出来，动调一下试试： 动调后发现这些函数全被更改了，汇编是这样的： call的那些函数是对input执行了一些简单的更改。 汇编： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990.text:004216F0 push ebp.text:004216F1 mov ebp, esp.text:004216F3 push 0Ah.text:004216F5 push 0.text:004216F7 mov eax, offset func_add.text:004216FC call eax ; loc_421510 //input[0] += 10.text:004216FC.text:004216FE add esp, 8.text:00421701 push 2.text:00421703 push 1.text:00421705 mov eax, offset func_xor.text:0042170A call eax ; loc_421510 //input[1] ^= input[2].text:0042170A.text:0042170C add esp, 8.text:0042170F push 7.text:00421711 push 2.text:00421713 mov eax, offset func_add.text:00421718 call eax ; loc_421510 //input[2] += 7.text:00421718.text:0042171A add esp, 8.text:0042171D push 7.text:0042171F push 3.text:00421721 mov eax, offset func_sub.text:00421726 call eax ; loc_421510 //input[3] = abs(input[3] - input[7]).text:00421726.text:00421728 add esp, 8.text:0042172B push 5.text:0042172D push 4.text:0042172F mov eax, offset func_xor.text:00421734 call eax ; loc_421510 //input[4] ^= input[5].text:00421734.text:00421736 add esp, 8.text:00421739 push 1.text:0042173B push 6.text:0042173D mov eax, offset func_sub.text:00421742 call eax ; loc_421510 //input[6] = abs(input[6] - input[1]).text:00421742.text:00421744 add esp, 8.text:00421747 push 3.text:00421749 push 7.text:0042174B mov eax, offset func_add.text:00421750 call eax ; loc_421510 //input[7] += 3.text:00421750.text:00421752 add esp, 8.text:00421755 push 7.text:00421757 push 8.text:00421759 mov eax, offset func_xor.text:0042175E call eax ; loc_421510 //input[8] ^= input[7].text:0042175E.text:00421760 add esp, 8.text:00421763 push 8.text:00421765 push 9.text:00421767 mov eax, offset func_sub.text:0042176C call eax ; loc_421510 //input[9] = abs(input[9] - input[8]).text:0042176C.text:0042176E add esp, 8.text:00421771 push 7.text:00421773 push 0Ah.text:00421775 mov eax, offset func_sub.text:0042177A call eax ; loc_421510 //input[10] = abs(input[10] - input[7]).text:0042177A.text:0042177C add esp, 8.text:0042177F push 0Ch.text:00421781 push 0Bh.text:00421783 mov eax, offset func_xor.text:00421788 call eax ; loc_421510 //input[11] ^= input[12].text:00421788.text:0042178A add esp, 8.text:0042178D push 2.text:0042178F push 0Ch.text:00421791 mov eax, offset func_sub.text:00421796 call eax ; loc_421510 //input[12] = abs(input[12] - input[2]).text:00421796.text:00421798 add esp, 8.text:0042179B push 0Fh.text:0042179D push 0Eh.text:0042179F mov eax, offset func_xor.text:004217A4 call eax ; loc_421510 //input[14] ^= input[15].text:004217A4.text:004217A6 add esp, 8.text:004217A9 push 2.text:004217AB push 0Fh.text:004217AD mov eax, offset func_add.text:004217B2 call eax ; loc_421510 //input[15] += 2.text:004217B2.text:004217B4 add esp, 8.text:004217B7 nop.text:004217B8 nop.text:004217B9 pop ebp.text:004217BA retn 写解密代码： 12345678910111213141516171819202122232425262728293031input = [0x17, 0x63, 0x77, 0x03, 0x52, 0x2E, 0x4A, 0x28, 0x52, 0x1B, 0x17, 0x12, 0x3A, 0x0A, 0x6C, 0x62]def add(a, b): input[a] -= bdef xor(a, b): input[a] ^= input[b]def sub(a, b): # maybe_input1.append(input[a] + input[b]) # maybe_input2.append(input[b] - input[a]) input[a] = abs(input[a] - input[b]) # 因为abs有两种可能性，全取这种可能得到的flag最正常key = &quot;MLGPOKFCJENIHDBA&quot;opcode = [1, 2, 1, 3, 2, 3, 1, 2, 3, 3, 2, 3, 2, 1] # 1表示加密中的add, 2表示xor, 3表示suba1 = [0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 14, 15] # 第一个参数a2 = [10, 2, 7, 7, 5, 1, 3, 7, 8, 7, 12, 2, 15, 2] # 第二个参数for i in range(13, -1, -1): if opcode[i] == 1: add(a1[i], a2[i]) elif opcode[i] == 2: xor(a1[i], a2[i]) elif opcode[i] == 3: sub(a1[i], a2[i])for i in range(16): input[i] ^= ord(key[i])for i in input: print(chr(i), end = &#x27;&#x27;) 得到flag： MRCTF{@_7r3e_f0r_fuNN!}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"http://example.com/categories/Reverse/"}],"tags":[{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"去OLLVM平坦化([SUCTF2019]hardCPP)","slug":"Reverse/LLVM","date":"2024-03-26T14:46:39.000Z","updated":"2024-04-11T13:53:32.020Z","comments":true,"path":"2024/03/26/Reverse/LLVM/","permalink":"http://example.com/2024/03/26/Reverse/LLVM/","excerpt":"","text":"去OLLVM平坦化([SUCTF2019]hardCPP)用ida打开是这样 十分有十二分的平坦化痕迹， 上次强网杯遇到过，但是因为当时没装好环境，deflat.py跑不出来，遗憾放弃。 这次又碰见不想再回避，打开这个网址把脚本装下来，https://github.com/Pure-T/deflat，看readme，要先装一个angr库（这个库在做VM虚拟机类题，写解析器脚本的时候也会很有用，以后可能再写） 1pip install angr 下载时间可能会有点长， 官方说的是用8.19.4.5版本，实际较新版本依然可用， 装好后用以下指令去平坦化： 12python deflat.py hardCpp 0x4007E0 #python + deflat.py + 文件名 + 起始地址(基本就是main函数的地址) 然而出错： 回看readme， 下载那个graph.py然后改名为am_graph.py ，将其与deflat.py放在同一目录下， 再次运行相同命令： 12python deflat.py hardCpp 0x4007E0 #python + deflat.py + 文件名 + 起始地址(基本就是main函数的地址) 期间可能会出现大量类似警告： 不要害怕，只要最后是这样就好： 将recovered的文件再放进ida里面看： 成功！ 下面就是逆向环节了也有部分去平坦化操作 首先排除上面这两个循环有用， 看到这一坨函数不要怕，其实就是c++里面的奇奇怪怪的东西（好像叫lambda表达式），来看看他们到底是干嘛的， 在对各函数分析的过程中发现在0x401310、0x4014E0和0x4016C0依然有平坦化，再跑脚本去一下， 1python deflat.py hardCpp_recovered 0x401310 0x401310： 再跑一遍 1python deflat.py hardCpp_recovered_recovered 0x4016C0 0x4016C0： 再跑一遍： 1python deflat.py hardCpp_recovered_recovered_recovered 0x4014E0 0x4014E0： 得到hardCPP_recovered_recovered_recovered_recovered 这次再放进ida并改名： 接下来就是搞清func1、func2、func3的功能： 其中两个就是是return第二个数据，另一个是add， 把这几个函数简化成表达式： 是不是已经非常清晰了！ 整理一下： 1v18 = (3 * (18 ^ input[i - 1 + v21]) + 2) ^ ((v21 ^ input[i]) + (input[i - 1 + v21] % 7)) 从前面看出：v21大概是0 （真的是大概，当时我也不太确定） 然后等式左边的v18就是enc[i]那么这个算法显然可逆： 把函数开头的md5解密一下： 那么flag（input）的第一位是‘#’ 好了可以写解密代码了： 12345678910enc = [0xF3, 0x2E, 0x18, 0x36, 0xE1, 0x4C, 0x22, 0xD1, 0xF9, 0x8C, 0x40, 0x76, 0xF4, 0x0E, 0x00, 0x05, 0xA3, 0x90, 0x0E, 0xA5]input = &#x27;#&#x27;k = len(input)for j in range(len(enc)): input += chr(((enc[j] ^ ((ord(input[j]) ^ 18) * 3 + 2)) - (ord(input[j]) % 7)) &amp; 0xff)print(input) flag： flag{mY-CurR1ed_Fns}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"http://example.com/categories/Reverse/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"},{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"浅谈VM虚拟机","slug":"Reverse/aboutvm","date":"2024-03-26T14:43:22.000Z","updated":"2024-04-14T08:09:33.551Z","comments":true,"path":"2024/03/26/Reverse/aboutvm/","permalink":"http://example.com/2024/03/26/Reverse/aboutvm/","excerpt":"","text":"浅谈VM虚拟机1. 什么是虚拟机？ 虚拟机：自己定义一套指令，在程序中能有一套函数和结构解释自己定义的指令并执行功能。 查一下维基百科 虚拟机（英语：virtual machine），在计算机科学中的体系结构里，是指一种特殊的软件，可以在计算机平台和终端用户之间创建一种环境，而终端用户则是基于虚拟机这个软件所创建的环境来操作其它软件。虚拟机（VM）是计算机系统的仿真器，通过软件模拟具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统，能提供物理计算机的功能。 有不同种类的虚拟机，每种虚拟机具有不同的功能： 系统虚拟机（也称为全虚拟化虚拟机）可代替物理计算机。它提供了运行整个操作系统所需的功能。虚拟机监视器（hypervisor）共享和管理硬件，从而允许有相互隔离但存在于同一物理机器上的多个环境。现代虚拟机监视器使用虚拟化专用硬件（主要是主机CPU）来进行硬件辅助虚拟化。 程序虚拟机 被设计用来在与平台无关的环境中执行计算机程序。 而我们CTF中遇到的虚拟机一般是这种： vm（虚拟机保护）是一种基于虚拟机的代码保护技术。他将基于x86汇编系统中的可执行代码转换为字节码指令系统的代码。来达到不被轻易篡改和逆向的目的。 2. 虚拟机的运行原理要搞清虚拟机的运行原理，最好的方法是手搓一个虚拟机出来： 一般虚拟机分为基于寄存器的虚拟机和基于栈的虚拟机，通过数据存储处理的方式区分，二者的区别可以看这里 栈式虚拟机和寄存器式虚拟机？ 这里先写一个简单的寄存器虚拟机， 实现虚拟机时，要做好这么几个步骤： 寄存器虚拟机需要初始化好栈空间和寄存器空间 定义一套opcode 实现opcode功能的模块 定义opcode和寄存器： 1234567891011121314enum regist&#123; R1 = 0xe1, R2 = 0xe2, R3 = 0xe3,&#125;;enum opcodes&#123; MOV = 0xf1, XOR = 0xf2, RET = 0xf4, READ = 0xf5,&#125;; 定义vm相关变量： 1234567891011121314typedef struct&#123; unsigned char opcode; void (*handle)(void*); //handler执行器&#125;vm_opcode;typedef struct vm_cpus&#123; int r1; int r2; int r3; unsigned char* eip; //指向opcode的指针 vm_opcode op_list[OPCODE_N]; //opcode列表，存储opcode和其对应的操作函数&#125;vm_cpu; 初始化vm各项数据，并使opcode关联handler功能函数 12345678910111213141516171819void vm_init(vm_cpu* cpu)&#123; cpu-&gt;r1 = 0; cpu-&gt;r2 = 0; cpu-&gt;r3 = 0; cpu-&gt;eip = (unsigned char*)vm_code; cpu-&gt;op_list[0].opcode = 0xf1; cpu-&gt;op_list[0].handle = (void (*)(void*))mov; //0xf1对应mov cpu-&gt;op_list[1].opcode = 0xf2; cpu-&gt;op_list[1].handle = (void (*)(void*))xor1; //0xf2对应xor cpu-&gt;op_list[2].opcode = 0xf5; cpu-&gt;op_list[2].handle = (void (*)(void*))read1; //0xf1对应read vm_stack = (char*)malloc(0x512); memset(vm_stack, 0, 0x512); //开辟栈空间&#125; vm启动函数： 123456void vm_start(vm_cpu* cpu)&#123; cpu-&gt;eip = (unsigned char*)vm_code; while((*cpu-&gt;eip) != RET) //持续执行opcode直到ret vm_dispatcher(cpu);&#125; 执行器： 123456789void vm_dispatcher(vm_cpu* cpu)&#123; for(int i = 0; i &lt; OPCODE_N; i++) if(*cpu-&gt;eip == cpu-&gt;op_list[i].opcode) &#123; cpu-&gt;op_list[i].handle(cpu); break; &#125;&#125; 再写出opcode： 123456789101112131415161718192021222324252627282930unsigned char vm_code[] = &#123; 0xf5, 0xf1,0xe1,0x0,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x0,0x00,0x00,0x00, 0xf1,0xe1,0x1,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x1,0x00,0x00,0x00, 0xf1,0xe1,0x2,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x2,0x00,0x00,0x00, 0xf1,0xe1,0x3,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x3,0x00,0x00,0x00, 0xf1,0xe1,0x4,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x4,0x00,0x00,0x00, 0xf1,0xe1,0x5,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x5,0x00,0x00,0x00, 0xf1,0xe1,0x6,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x6,0x00,0x00,0x00, 0xf1,0xe1,0x7,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x7,0x00,0x00,0x00, 0xf1,0xe1,0x8,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x8,0x00,0x00,0x00, 0xf1,0xe1,0x9,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x9,0x00,0x00,0x00, 0xf1,0xe1,0xa,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xa,0x00,0x00,0x00, 0xf1,0xe1,0xb,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xb,0x00,0x00,0x00, 0xf1,0xe1,0xc,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xc,0x00,0x00,0x00, 0xf1,0xe1,0xd,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xd,0x00,0x00,0x00, 0xf1,0xe1,0xe,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xe,0x00,0x00,0x00, 0xf1,0xe1,0xf,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xf,0x00,0x00,0x00, 0xf1,0xe1,0x10,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x10,0x00,0x00,0x00, 0xf1,0xe1,0x11,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x11,0x00,0x00,0x00, 0xf1,0xe1,0x12,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x12,0x00,0x00,0x00, 0xf1,0xe1,0x13,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x13,0x00,0x00,0x00, 0xf1,0xe1,0x14,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x14,0x00,0x00,0x00, 0xf1,0xe1,0x15,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x15,0x00,0x00,0x00, 0xf1,0xe1,0x16,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x16,0x00,0x00,0x00, 0xf1,0xe1,0x17,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x17,0x00,0x00,0x00, 0xf1,0xe1,0x18,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x18,0x00,0x00,0x00, 0xf1,0xe1,0x19,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x19,0x00,0x00,0x00, 0xf4&#125;; 寄存器虚拟机完成。 3. 给个实例，出个小题上面的虚拟机大概实现的就是这个过程 1234567call read1MOV R1,flag[i]XOR R1 0x12MOV [OFFEST],R1; //循环len(flag)次ret 也就是实现了 12for(int i = 0; i &lt; strlen(flag); i++) flag[i] ^= 0x12; 的功能。 把源码放在这： maybeVM 4. 如何破解VM虚拟机保护类题目 解题一般步骤： 分析VM结构-&gt;分析opcode-&gt;编写parser-&gt;re算法 VM结构常见类型： 基于栈、基于队列、基于信号量 opcode： 与VM数据结构对应的指令 ：push pop 运算指令：add、sub、mul等 示例1链接：[NewStarCTF 2023 公开赛道]茶 用来简单了解VM原理 ——by me 示例2链接：[watevrCTF 2019]Repyc——WriteUp pyc+混淆+VM虚拟机 ——by me","categories":[{"name":"Reverse","slug":"Reverse","permalink":"http://example.com/categories/Reverse/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"},{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]}],"categories":[{"name":"Reverse","slug":"Reverse","permalink":"http://example.com/categories/Reverse/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"},{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]}