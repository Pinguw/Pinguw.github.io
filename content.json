{"meta":{"title":"Pinguw's Blog","subtitle":"","description":"","author":"Pinguw","url":"http://example.com","root":"/"},"pages":[{"title":"关于博主","date":"2024-06-02T15:26:14.725Z","updated":"2024-06-02T15:26:14.725Z","comments":true,"path":"aboutme.html","permalink":"http://example.com/aboutme.html","excerpt":"","text":"小时候打喷嚏，总觉得是谁在偷偷想自己。现在看来，说不定是长大的自己在想念小时候的自己。 2023年8月 - 刚得知自己考上大学就稀里糊涂地被拉去打了新生赛。（那时候的我还不知道自己已经踏上了一条不归路） 2023年10月 - 新生赛的征程结束，大家都各自选好了自己的方向，即使到现在我也不知为何会选择在逆向上走下去。我队已经3年没人做逆向了，不妨把这算作一条理由罢。 2023年11月 - 首次参加企业比赛HWS，虽然最后的奖金只有300米，但也是一次极棒的体验和学习经历。 2024年3月 - 我大抵是完全放弃了深造下去的念头。唉，但是谁不想读研啊，我也想学习啊。。。 2024年4月13日 - 校赛，其中五道逆向，斩获四道一血，一道二血，算是不负众望吧。 2024年4月 - Pinguw加入HASHTEAM！！！ 2024年4月17日 - 跟着其他队员首次接触到AWD模式，然鹅只有挨打的份。说实话，即使是什么也不会（只能改个弱口令），也能真切地感受到这个比赛模式的紧张与刺激。也是，AWD里，逆向手又能做什么呢？ 2024年4月21日 - 成功加入山东大学镜像站，负责后端开发。第一个任务是…五一前把现在的后端看完。 2024年5月13日 - 带队拿到首奖，大家辛苦了（补一句：社工真好玩，社不出来不好玩）。 2024年5月18日、19日 - 首次CISCN（CTF国赛），承担了全队的re出题，虽然水平还是不够，但还是够得上各方向的平均数吧。 2024年6月2日 - Pinguw加入Nepnep！！！"},{"title":"赞助我","date":"2024-06-05T07:44:12.737Z","updated":"2024-06-05T07:44:12.737Z","comments":true,"path":"donate.html","permalink":"http://example.com/donate.html","excerpt":"","text":"不必赞助我了，把钱留给自己和父母吧，先学会对自己好，也要记得及时报养育之恩。 赞助单感谢施主大恩大德！ 时间 捐助人 金额 留言 2024-6-5 yujia 0.5 V你50"},{"title":"文章归档","date":"2024-04-11T13:54:27.378Z","updated":"2024-04-11T13:54:27.378Z","comments":true,"path":"archives.html","permalink":"http://example.com/archives.html","excerpt":"","text":""},{"title":"我的朋友","date":"2024-06-07T08:18:46.235Z","updated":"2024-06-07T08:18:46.235Z","comments":true,"path":"friends.html","permalink":"http://example.com/friends.html","excerpt":"","text":"我们会慢慢长大成人，随着季节的不停变换路边盛开的鲜花也在不断变化，那个季节盛开的鲜花到底叫什么名字，轻轻摇曳着一旦触摸它就会轻轻地被扎到，用鼻子靠近闻一闻，会有一股淡淡的青涩太阳的芳香，随着那股香味慢慢变淡我们也在长大成人，但是那朵花一定会在某处继续盛开。 朋友们每次编译时，随机排序"},{"title":"","date":"2024-06-03T08:07:26.436Z","updated":"2024-06-03T08:07:26.436Z","comments":true,"path":"diary/2024年第一份月报.html","permalink":"http://example.com/diary/2024%E5%B9%B4%E7%AC%AC%E4%B8%80%E4%BB%BD%E6%9C%88%E6%8A%A5.html","excerpt":"","text":"先说总结：前半个月很闲，后半个月忙飞，但是收获满满的一个月！5.1-5.5刚从失落中逃出来，恰好是五一可以休整一下。原本也是没想回家的，但爸妈来青玩，顺便也给我接回去。 看一下五一山青旁边的滨海公园： 回家后没什么好说的，睡觉+打游戏循环，偶尔被拉过去打打工做几道re。 当然，做做水题罢了，遇到难题直接开摆。 get到一个新游戏，永劫真好玩。 5.9放完假回来更不想上课了，今天实在困得不行连从不敢逃的高数都不去上了。（又打了一天劫） 明天是校运会，冲掉了一天课，本来想着去济南，可惜朋友很忙没空带我转转，有机会再去。 5.12-5.19中间断更的几天没什么好写的，就是上班+打劫。 然后就是比赛、比赛、比赛，无休止的比赛，我还以为上课打H&amp;N已经够离谱了，没想到这两天的国赛强度更大，先不说做不做得出来，就是搁那坐着不能看QQ就挺折磨了。 5.22高数老师换成之前那个不点名的了，现在平均每周两三节课了（ 上课是不可能上课的，反正都是突击复习一下就能过的东西，学好了说实话也没什么用。 5.26-5.27京麒+RCTF+DragonKnightCTF+上海磐石（没打）四联，什么CTF期末周。 听王师傅的话，给Nepnep投了个简历。 6.2虽然DASCTF爆零了，但是收到了好消息： 经历两轮面试，终于 成功加入Nepnep！ 但现在回头看，算是比较平常的一个月。"}],"posts":[{"title":"HASHCTF2024-Reverse题解","slug":"比赛WP/HASHCTF2024","date":"2024-06-05T07:47:44.000Z","updated":"2024-06-05T08:24:23.463Z","comments":true,"path":"2024/06/05/比赛WP/HASHCTF2024/","permalink":"http://example.com/2024/06/05/%E6%AF%94%E8%B5%9BWP/HASHCTF2024/","excerpt":"","text":"校赛也是ak re了，总排名第二，一等奖+Reverse单项最佳。 一人干活，七人围观！主要逻辑在这里： 是个多线程代码，线程影响v3的取值和异或的对象，直接上代码： #include &lt;cstdio&gt;void dec(unsigned char* enc)&#123; char key[] = &quot;HASH2024&quot;; for(int round = 1; round &lt;= 8; round++) &#123; for(int count = 8; count &gt;= 1;) &#123; int v4 = 8 - count; int v3 = ((4 * round) | round) ^ key[8 - count--]; for(int i = 0; i &lt; 8; i++) enc[v4 * 8 + i] ^= v3; &#125; &#125; for(int i = 0; i &lt; 64; i++) printf(&quot;%c&quot;, enc[i]);&#125;int main()&#123; unsigned char enc_flag[] = &#123; 0x60, 0x69, 0x7B, 0x60, 0x6B, 0x7C, 0x6E, 0x53, 0x66, 0x18, 0x5F, 0x77, 0x7D, 0x77, 0x40, 0x1C, 0x5E, 0x1B, 0x77, 0x1B, 0x50, 0x58, 0x44, 0x18, 0x5A, 0x1B, 0x4C, 0x77, 0x1F, 0x40, 0x1B, 0x77, 0x4B, 0x18, 0x46, 0x4B, 0x7D, 0x5A, 0x02, 0x1A, 0x4D, 0x46, 0x4B, 0x51, 0x77, 0x18, 0x4E, 0x77, 0x1F, 0x40, 0x1B, 0x77, 0x6B, 0x77, 0x44, 0x1C, 0x46, 0x4F, 0x5D, 0x1C, 0x4F, 0x1B, 0x09, 0x55 &#125;; dec((unsigned char*)enc_flag); return 0;&#125; HASHCTF{N1w_U_h4v3_3xpl0r3d_7h3_c0ncUr*2ency_0f_7h3_c_l4ngu4g3!} 解完之后想起来，既然加密是异或，大概率调试的时候把密文输入，那么最后判断时的结果就是flag，出题人的回答印证了我的猜想，不过是一血，没什么影响。 Teaflower十分钟秒杀题。 有壳去壳，有花去花， 壳是简单的upx一键去，花是简单的跳转全nop， TEA的delta魔改了一下，直接写解密代码： #include &lt;iostream&gt;#include &lt;cstdio&gt;void decrypt (uint32_t* v, uint32_t* k)&#123; uint32_t v0 = v[0], v1 = v[1], sum = 0xBABEEAEA * 32; uint32_t delta = 0xBABEEAEA; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for(int i = 0; i &lt; 32; i++) &#123; v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); sum -= delta; &#125; v[0] = v0; v[1] = v1;&#125;int main()&#123; unsigned char enc_flag[] = &#123; 0x32, 0x31, 0x75, 0x08, 0x27, 0x72, 0xD5, 0x62, 0xE9, 0x2C, 0xA5, 0xAE, 0x98, 0x03, 0x5E, 0x4F, 0xEB, 0x25, 0xC3, 0xAD, 0xBB, 0x25, 0x49, 0x7D, 0x88, 0xAE, 0x9C, 0x73, 0x21, 0x37, 0xAA, 0x4D, 0x77, 0xA1, 0xBA, 0x08, 0xE9, 0xBB, 0x28, 0x29, &#125;; unsigned char key[32] = &quot;HASH2024HASH2024&quot;; for(int i = 0; i &lt; 40; i += 8) decrypt((unsigned int*)&amp;enc_flag[i], (unsigned int*)key); for(int i = 0; i &lt; 40; i++) printf(&quot;%c&quot;, enc_flag[i]); return 0;&#125; HASHCTF{W0o0w_U_cAn_r3@11y_r3v3r53_14!!} babycode我忘了是怎么知道的以太坊虚拟机（大概是拷打GPT的时候它招的供词），找一个能把字节码还原成汇编的网站https://ethervm.io/decompile： 发现有两处位置一直在push数据，将两块数据扒下来，后面还有XOR指令加上出题人提示，将两块数据异或，得到flag： data1 = [0x1b, 0x24, 0x30, 0x3d, 0x31, 0x31, 0x0d, 0x3e, 0x0a, 0x0a, 0x4f, 0x67, 0x3a, 0x09, 0x51, 0x30, 0x08, 0x13, 0x32, 0x2b, 0x0d, 0x26, 0x3c, 0x24, 0x30, 0x78, 0x27, 0x67, 0x19, 0x2d, 0x57, 0x46, 0x57, 0x46, 0x2c, 0x07, 0x7e, 0x10, 0x4e]data2 = [0x53, 0x65, 0x63, 0x75, 0x72, 0x65, 0x4b, 0x45, 0x59, 0x3a, 0x20, 0x57, 0x65, 0x6c, 0x63, 0x6f, 0x6d, 0x65, 0x5f, 0x74, 0x6f, 0x5f, 0x48, 0x41, 0x53, 0x48, 0x43, 0x54, 0x46, 0x5f, 0x32, 0x30, 0x32, 0x34, 0x5f, 0x34, 0x5f, 0x31, 0x33]for i in range(len(data1)): print(chr(data1[i] ^ data2[i]), end = &#x27;&#x27;) HASHCTF{S0o0_e2_evm_bytec0d3_revers3!!} 高速龙车驾驶员直接运行报错需要支持库，走出题人不建议的路线loongarch交叉编译工具链（因为建议的路我不会走）， 安装后里面有loongarch64-objdump，用他dump出文件的汇编代码和数据段： 对照出题人给的文档，分析汇编： ... sp -= 32 sp[8] = s1 sp[16] = s0 sp[24] = ra a1 += 7612 t0 += 171 xr1 = a1 xr0 = a1[32] t1 += 160 xr2 = t0 for (int i = 0; i &lt; 4; i++) xr0 ^= xr2 xr0 = a1[32] xr3 = t1 a0 = 8 a0 = 152 for (int i = 0; i &lt; 4; i++) xr1 ^= xr3 a1[0] = xr1... 关键部分如上：异或加密。 从扒出的数据段中做尝试，最终试出将data段与rodata段异或得到flag。 data1 = [0x5e, 0x7f, 0xec, 0x4f, 0x32, 0x30, 0xbb, 0x6c, 0x6b, 0xd7, 0x69, 0x70, 0xd7, 0xba, 0x53, 0x37]data2 = [0x80, 0Xef, 0X4c, 0X69, 0X92, 0X9c, 0X38, 0X91, 0X92, 0Xb6, 0X38, 0Xde, 0X28, 0X0e, 0Xcd, 0X63]data3 = [0xcd, 0xa2, 0xc1, 0x23, 0xbd, 0x30, 0xf5, 0x3a, 0x26, 0x33, 0xda, 0xfc, 0xaf, 0xad, 0xfa, 0x2d]data4 = [0x8d, 0x20, 0x54, 0x2b, 0x37, 0x91, 0x5e, 0xad, 0xd0, 0xf8, 0xb2, 0xe7, 0xea, 0xfe, 0xc1, 0xc7]key1 = [0x16, 0x3e, 0xbf, 0x07, 0x71, 0x64, 0xfd, 0x17, 0x32, 0xb8, 0x1c, 0x2f, 0x88, 0xd1, 0x3d, 0x58]key2 = [0xf7, 0xb0, 0x13, 0x36, 0xde, 0xf3, 0x08, 0xfe, 0xfd, 0x86, 0x57, 0xb1, 0x18, 0x60, 0xaa, 0x22]key3 = [0xbf, 0xc1, 0xa9, 0x7c, 0xe2, 0x6f, 0xb9, 0x7b, 0x75, 0x6b, 0x85, 0xa3, 0xfc, 0xc2, 0xca, 0x42]key4 = [0xe2, 0x10, 0x3b, 0x44, 0x07, 0xce, 0x01, 0xf2, 0x87, 0x9d, 0xde, 0x8b, 0xcb, 0xdf, 0xbc, 0xc7]for i in range(len(data1)): print(chr(data1[i] ^ key1[i]), end = &#x27;&#x27;)for i in range(len(data1)): print(chr(data2[i] ^ key2[i]), end = &#x27;&#x27;)for i in range(len(data1)): print(chr(data3[i] ^ key3[i]), end = &#x27;&#x27;)for i in range(len(data1)): print(chr(data4[i] ^ key4[i]), end = &#x27;&#x27;) HASHCTF{You__ know__ _ Lo0oo0oo0ngArch___ LASX_ _So0oo0oo0___Well!!} xorust简单恢复一下符号表： 在func函数中找到关键部分： 扒取数据： 发现这些数据比input少一位，试着在最前面加 H或者在最后面加 &#125;， 写出解密代码： data = [0x09, 0x12, 0x1B, 0x0B, 0x17, 0x12, 0x3D, 0x2C, 0x32, 0x54, 0x52, 0x53, 0x5D, 0x08, 0x3A, 0x10, 0x3A, 0x07, 0x2D, 0x0D, 0x27, 0x06, 0x27, 0x0B, 0x12, 0x0D, 0x33, 0x07, 0x47, 0x41, 0x2D, 0x6B, 0x5B, 0x30, 0x15, 0x7A, 0x59, 0x07, 0x31, 0x2B, 0x3C, 0x2D, 0x26, 0x2C, 0x22, 0x3D, 0x0D]data[0] ^= ord(&#x27;H&#x27;)print(&#x27;H&#x27;, end = &#x27;&#x27;)for i in range(1, len(data)): data[i] ^= data[i - 1]for i in data: print(chr(i), end = &#x27;&#x27;) HASHCTF{We1c0me_Our_RusT_M@st3r_4o_J0in_tHeCoMp}","categories":[{"name":"比赛WP","slug":"比赛WP","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9BWP/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/tags/WriteUp/"}]},{"title":"RCTF2024部分题解","slug":"比赛WP/RCTF2024","date":"2024-05-29T12:52:43.000Z","updated":"2024-06-05T08:07:25.456Z","comments":true,"path":"2024/05/29/比赛WP/RCTF2024/","permalink":"http://example.com/2024/05/29/%E6%AF%94%E8%B5%9BWP/RCTF2024/","excerpt":"","text":"四道re（那个misc就是纯逆向） Reverse2048审计源码，看出每轮将获得分数为输入的sorce，上限为当前得分，初次上限为1w，那么每次成功分数翻倍的情况下用不了几次即可到达100w分： RCTF{you_are_2048_master} bloker_vm在每种case中下断点，可得到加密逻辑， 但是没看出反调试的影响在哪里。 解密代码： #include &lt;cstdio&gt;int rc4(unsigned char* input, int input_len, char* key, int key_len)&#123; int result; // eax char v5; // [esp+D3h] [ebp-155h] char v6; // [esp+D3h] [ebp-155h] int v7; // [esp+F4h] [ebp-134h] int i; // [esp+100h] [ebp-128h] int j; // [esp+100h] [ebp-128h] int k; // [esp+100h] [ebp-128h] unsigned __int8 v11; // [esp+10Fh] [ebp-119h] unsigned __int8 v12; // [esp+11Bh] [ebp-10Dh] char v13[260]; // [esp+124h] [ebp-104h] for(i = 0; i &lt; 256; ++i) v13[i] = i; v7 = 0; for(j = 0; j &lt; 256; ++j) &#123; v7 = ((unsigned __int8)key[j % key_len] + v7 + (unsigned __int8)v13[j]) % 256; v5 = v13[j]; v13[j] = v13[v7]; v13[v7] = v5; &#125; v12 = 0; v11 = 0; for(k = 0; ; ++k) &#123; result = k; if(k &gt;= input_len) break; v11 += v13[++v12]; v6 = v13[v12]; v13[v12] = v13[v11]; v13[v11] = v6; input[k] ^= v13[((unsigned __int8)v13[v11] + (unsigned __int8)v13[v12]) % 256]; &#125; return result;&#125;int main()&#123; unsigned char enc_flag[] = &#123; 0x80, 0x05, 0xE3, 0x2F, 0x18, 0x2F, 0xC5, 0x8C, 0x25, 0x70, 0xBC, 0x05, 0x1C, 0x4F, 0xF2, 0x02, 0xE5, 0x3E, 0x02, 0x2F, 0xE5, 0x11, 0xA3, 0xC0 &#125;; char key[] = &quot;thisisyoursecretkey&quot;; rc4(enc_flag, 24, key, 18); for(int i = 0; i &lt; 24; i++) &#123; enc_flag[i] = (enc_flag[i] &lt;&lt; 2) &amp; 63 | (enc_flag[i] &gt;&gt; 6); enc_flag[i] ^= 0x7D; printf(&quot;%c&quot;, enc_flag[i]); &#125; return 0;&#125; RCTF{a_baby_debug_bloker} PPTT看到mian函数中先将输入写成二叉树层序存储，然后先序和中序遍历，并对中序的结果进行交换混淆， v23，v24，v25存储的即为中序遍历的结果，z3解方程可得 z3解方程+还原： from Crypto.Util.number import *from z3 import *v17 = BitVec(&#x27;v17&#x27;, 64)v18 = BitVec(&#x27;v18&#x27;, 64)v19 = BitVec(&#x27;v19&#x27;, 64)v20 = BitVec(&#x27;v20&#x27;, 64)v23 = BitVec(&#x27;v23&#x27;, 64)v24 = BitVec(&#x27;v24&#x27;, 64)v25 = BitVec(&#x27;v25&#x27;, 64)s = Solver()s.add(v20 == v24 &amp; v23)s.add(v19 == (v24 &amp; v23 | v25 &amp; v23) + 65670)s.add(v18 == (v25 &amp; v23 ^ v25 &amp; v24) - 1131796)s.add(v17 == v24 &amp; v23 ^ v25 &amp; v23)# s.add((v24 &amp; v23 &amp; (~(v24 | v23) | v25 &amp; v23 | v25 &amp; v24 &amp; ~v18) | v25 &amp; v24 &amp; v18) != 0x67437616)s.add((v23 ^ (v20 &amp; ~v18 | v20 &amp; ~v19 | v17 &amp; v19 | v25 &amp; v23 &amp; ~v18)) == 0x400010000622000)s.add((v18 ^ (v19 - v20)) == 0x2100A0203EFBB8B)s.add((v17 ^ v19 ^ v20) == 0x4083102108E)s.add((v19 ^ v17) - v18 == 0x1551566F3C6485ED)s.add((v18 ^ v19 ^ v25 &amp; v24) == 0x40836ECAB9A)s.add((v17 ^ v20) - v18 == 0x3E51566F3C718563)s.add(v23 - v24 == 0x1AEFF6FDFC121BF1)s.add((v25 + v24 + v23) % 10 == 8)while s.check() == sat: model = s.model() tmp = long_to_bytes(model[v25].as_long()) s.add(v25 != model[v25]) if len(str(tmp)) != 11 or tmp.find(b&#x27;C&#x27;) == -1 or tmp.find(b&#x27;F&#x27;) == -1 or tmp.find(b&#x27;&#125;&#x27;) == -1: continue mid1 = long_to_bytes(model[v23].as_long()) mid2 = long_to_bytes(model[v24].as_long()) mid3 = long_to_bytes(model[v25].as_long()) # print(mid1[::-1]) # print(mid2[::-1]) # print(mid3[::-1]) str1 = &#x27;0123456789abcdefghijklmn&#x27; str2 = &#x27;gefckamb52hl48i0n1j396d7&#x27; mid = mid1[::-1]+mid2[::-1]+mid3[::-1] flag = &#x27;&#x27; for i in range(24): flag += chr(mid[str2.find(str1[i])]) print(flag) 一个一个验证所有解 RCTF{sjknwemqspsdaqtyua} Miscs1ayth3sp1re这应该是个re题。 把文件拖进jadx查找判断胜利的条件： 直接看加密逻辑，简单异或： 写解密代码： arr1 = [164, 158, 95, 107, 4, 215, 108, 115, 5, 8, 25, 57, 41, 236, 231, 17, 85]arr2 = [246, 221, 11, 45, 127, 148, 45, 36, 70, 73, 78, 8, 98, 141, 140, 112, 40]enc1 = [0] * len(arr1)for i in range(len(arr1)): enc1[i] = arr1[i] ^ arr2[i] print(chr(enc1[i]), end = &#x27;&#x27;)print()arr3 = [100, 174, 197, 56]arr4 = [2, 0xC2, 164, 95]enc2 = [0] * len(arr3)for i in range(len(arr3)): enc2[i] = arr3[i] ^ arr4[i] print(chr(enc2[i]), end = &#x27;&#x27;) RCTF{CAWCAW1Kaka}","categories":[{"name":"比赛WP","slug":"比赛WP","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9BWP/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/tags/WriteUp/"}]},{"title":"CISCN2024-Reverse部分题解","slug":"比赛WP/CISCN2024","date":"2024-05-22T07:21:02.000Z","updated":"2024-06-05T08:08:20.086Z","comments":true,"path":"2024/05/22/比赛WP/CISCN2024/","permalink":"http://example.com/2024/05/22/%E6%AF%94%E8%B5%9BWP/CISCN2024/","excerpt":"","text":"很菜，初赛只出了三道题。 asm_re拿到手是IDA的view界面， main函数逻辑交给GPT，是简单的加减乘除异或， data段手动dump出+解密： data = [ 0xD7, 0x1F, 0x00, 0x00, 0xB7, 0x21, 0x00, 0x00, 0x47, 0x1E, 0x00, 0x00, 0x27, 0x20, 0x00, 0x00, 0xE7, 0x26, 0x00, 0x00, 0xD7, 0x10, 0x00, 0x00, 0x27, 0x11, 0x00, 0x00, 0x07, 0x20, 0x00, 0x00, 0xC7, 0x11, 0x00, 0x00, 0x47, 0x1E, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0xF7, 0x11, 0x00, 0x00, 0x07, 0x20, 0x00, 0x00, 0x37, 0x10, 0x00, 0x00, 0x07, 0x11, 0x00, 0x00, 0x17, 0x1F, 0x00, 0x00, 0xD7, 0x10, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0x67, 0x1F, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0xC7, 0x11, 0x00, 0x00, 0xC7, 0x11, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0xD7, 0x1F, 0x00, 0x00, 0x17, 0x1F, 0x00, 0x00, 0x07, 0x11, 0x00, 0x00, 0x47, 0x0F, 0x00, 0x00, 0x27, 0x11, 0x00, 0x00, 0x37, 0x10, 0x00, 0x00, 0x47, 0x1E, 0x00, 0x00, 0x37, 0x10, 0x00, 0x00, 0xD7, 0x1F, 0x00, 0x00, 0x07, 0x11, 0x00, 0x00, 0xD7, 0x1F, 0x00, 0x00, 0x07, 0x11, 0x00, 0x00, 0x87, 0x27, 0x00, 0x00]print(len(data) // 4)tmp = &#x27;&#x27;for i in range(0, len(data), 4): if(len(hex(data[i])[2:]) == 1): tmp = &#x27;0&#x27; + hex(data[i])[2:] else: tmp = hex(data[i])[2:] print(&#x27;0x&#x27;, hex(data[i + 1])[2:], tmp, sep = &#x27;&#x27;, end = &#x27;, &#x27;)print()flag = [ 0x1fd7, 0x21b7, 0x1e47, 0x2027, 0x26e7, 0x10d7, 0x1127, 0x2007, 0x11c7, 0x1e47, 0x1017, 0x1017, 0x11f7, 0x2007, 0x1037, 0x1107, 0x1f17, 0x10d7, 0x1017, 0x1017, 0x1f67, 0x1017, 0x11c7, 0x11c7, 0x1017, 0x1fd7, 0x1f17, 0x1107, 0xf47, 0x1127, 0x1037, 0x1e47, 0x1037, 0x1fd7, 0x1107, 0x1fd7, 0x1107, 0x2787]for i in range(38): print(chr((((flag[i] - 30) ^ 70) - 20) // 80), end = &#x27;&#x27;) flag{67e9a228e45b622c2992fb5174a4f5f5} androidso_re从jadx中看到是CBC的DES， 进so看getkey和getiv的加密方式， key是简单的RC4加异或，iv是凯撒密码。 key: iv: 对key和iv的解密： RC4_key = [0x42, 0xb1, 0x66, 0xdc, 0x03, 0x6d, 0x45, 0x1b, 0xc2, 0x3b, 0x58, 0xba]xor_key = [0x03, 0x89, 0x33, 0xB8, 0x54, 0x0C, 0x20, 0x6A]for i in range(len(xor_key)): print(chr(RC4_key[i + k] ^ xor_key[i]), end = &#x27;&#x27;)print()enc_iv = &quot;F2IjBOh1mRW=&quot;for i in enc_iv: if(i.islower()): print(chr(ord(&#x27;a&#x27;) + (ord(i) - 81) % 26), end = &#x27;&#x27;) elif(i.isupper()): print(chr(ord(&#x27;A&#x27;) + (ord(i) - 49) % 26), end = &#x27;&#x27;) else: print(i, end = &#x27;&#x27;) DES的解密： flag{188cba3a5c0fbb2250b5a2e590c391ce} gdb_debug 动调出两处xor_key和一个sbox，然后写代码解密： # XORenc_flag = [0xBF, 0xD7, 0x2E, 0xDA, 0xEE, 0xA8, 0x1A, 0x10, 0x83, 0x73, 0xAC, 0xF1, 0x06, 0xBE, 0xAD, 0x88, 0x04, 0xD7, 0x12, 0xFE, 0xB5, 0xE2, 0x61, 0xB7, 0x3D, 0x07, 0x4A, 0xE8, 0x96, 0xA2, 0x9D, 0x4D, 0xBC, 0x81, 0x8C, 0xE9, 0x88, 0x78, 0x00, 0x00,]key = &quot;congratulationstoyoucongratulationstoy&quot;for i in range(38): enc_flag[i] ^= ord(key[i])#==============================================================================# XORc = [0x03, 0x12, 0x0C, 0x4C, 0xC6, 0x26, 0x8C, 0x63, 0xB6, 0x87, 0xB0, 0x6F, 0x1A, 0xCB, 0x9B, 0xFD, 0xBC, 0x52, 0x79, 0x93, 0x19, 0x6A, 0xDA, 0x4E,0x7B, 0xF9, 0xC4, 0xBB, 0xF1, 0x7E, 0x9D, 0x1E,0x44, 0xD6, 0xC5, 0x50, 0xBF, 0xEE, 0x00, 0x00,]d = [0xDD, 0xB8, 0x4E, 0xB0, 0xCF, 0xCE, 0x3E, 0x65,0xBB, 0x14, 0xD1, 0x9B, 0x3E, 0x82, 0x8E, 0xFC,0x6B, 0xF9, 0x7D, 0x8B, 0xD6, 0x83, 0x0F, 0xD8,0x48, 0x33, 0x3D, 0x91, 0xAF, 0x94, 0xB0, 0x22,0xD0, 0xB9, 0xFD, 0xCD, 0xE7, 0x04, 0x00, 0x00,]# for i in c:# for j in range(15, -1, -2):# print(&#x27;0x&#x27;+i[j - 1]+i[j]+&#x27;, &#x27;, end = &#x27;&#x27;)# print()# print()# for i in d:# for j in range(15, -1, -2):# print(&#x27;0x&#x27;+i[j - 1]+i[j]+&#x27;, &#x27;, end = &#x27;&#x27;)# print()xor_key2 = [0] * 38for i in range(38): xor_key2[i] = c[i] ^ d[i]for i in range(38): enc_flag[i] ^= xor_key2[i]#==============================================================================# ENCs_box = [0x12, 0x0E, 0x1B, 0x1E, 0x11, 0x05, 0x07, 0x01, 0x10, 0x22, 0x06, 0x17, 0x16, 0x08, 0x19, 0x13, 0x04, 0x0F, 0x02, 0x0D, 0x25, 0x0C, 0x03, 0x15,0x1C, 0x14, 0x0B, 0x1A, 0x18, 0x09, 0x1D, 0x23,0x1F, 0x20, 0x24, 0x0A, 0x00, 0x21, 0x00, 0x00,]# for i in s_box:# for j in range(15, -1, -2):# print(&#x27;0x&#x27;+i[j - 1]+i[j]+&#x27;, &#x27;, end = &#x27;&#x27;)# print()flag = [0] *38for i in range(38): flag[s_box[i]] = enc_flag[i]#==============================================================================# XORa = r&quot;flag&#123;0123456789abcdef0123456789abcdef&#125;&quot;b = [0xBF, 0x63, 0x79, 0xDA, 0xBC, 0x26, 0xB0, 0x8C, 0xCB, 0x7E, 0x50, 0xC4, 0x6A, 0x93, 0x12, 0x52, 0xB6, 0xC6, 0x03, 0xFD, 0xF9, 0x4E, 0x1A, 0x6F,0xF1, 0x9B, 0xBB, 0x0C, 0x7B, 0x9D, 0x4C, 0x44,0xD6, 0xEE, 0x87, 0x1E, 0xC5, 0x19, 0x00, 0x00,]# for i in b:# for j in range(15, -1, -2):# print(&#x27;0x&#x27;+i[j - 1]+i[j]+&#x27;, &#x27;, end = &#x27;&#x27;)# print()for i in range(38): xor_key1[i] = ord(a[i]) ^ b[i]for i in range(38): flag[i] ^= xor_key1[i]xor_key1 = [0] * 38#==============================================================================for i in range(38): print(chr(flag[i]), end = &#x27;&#x27;) flag{78bace5989660ee38f1fd980a4b4fbcd}","categories":[{"name":"比赛WP","slug":"比赛WP","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9BWP/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/tags/WriteUp/"}]},{"title":"H&NCTF2024-Reverse部分题解","slug":"比赛WP/H&NCTF2024","date":"2024-05-13T15:48:29.000Z","updated":"2024-06-05T08:08:38.011Z","comments":true,"path":"2024/05/13/比赛WP/H&NCTF2024/","permalink":"http://example.com/2024/05/13/%E6%AF%94%E8%B5%9BWP/H&NCTF2024/","excerpt":"","text":"其他的re就没时间做了（我承认是我菜） Baby_OBVBS打开之后看见是VBS混淆，将混淆部分打印出来（base64内容部分略去）： eAqi = &quot;59fc6b263c3d0fcbc331ade699e62d3473bbf85522d588e3423e6c751ca091528a3c0186e460483917192c14&quot;ANtg = &quot;baacc7ffa8232d28f814bb14c428798b&quot;Function Base64Decode(base64EncodedString) Dim xml, elem Set xml = CreateObject(&quot;MSXML2.DOMDocument&quot;) Set elem = xml.createElement(&quot;tmp&quot;) elem.dataType = &quot;bin.base64&quot; elem.text = base64EncodedString Dim stream Set stream = CreateObject(&quot;ADODB.Stream&quot;) stream.Type = 1 &#x27;Binary stream.Open stream.Write elem.nodeTypedValue stream.Position = 0 stream.Type = 2 &#x27;Text stream.Charset = &quot;utf-8&quot; Base64Decode = stream.ReadText stream.CloseEnd Functionnbbt=&quot;RnVuY3Rpb24gSW5pdGlhbGl6ZShzdHJQd2QpDQogICAgRGltIGJveCgyNTYpDQogICAgRGltIHRlbXBTd2FwDQogICAgRGltIGENCiAg&quot;execute base64Decode(nbbt)NFqt=&quot;RnVuY3Rpb24gTXlmdW5jKHNZCBGdW5jdGlvbg==&quot;execute base64Decode(NFqt)NsFw=&quot;RnVuY3Rpb24gRWNTYpDQogICAgICAgIGVuY3J5cHRlZERhdGEgPSBlbmNyeXB0ZWREYXRhICYgTENhc2UoUmlnaHQoIjAiICYgSGV4KHkpLCAyKSkNCiAgICBOZXh0DQogICAgRW5DcnlwdCA9IGVuY3J5cHRlZERhdGENCkVuZCBGdW5jdGlvbg==&quot;execute base64Decode(NsFw)hYLu=&quot;bXNnYm94ICJEbyB5b3Uga28gImJ5ZSEi&quot;execute base64Decode(hYLu) base64解密后得到加密代码： Function RC4_init(strPwd) Dim box(256) Dim tempSwap Dim a Dim b For i = 0 To 255 box(i) = i Next a = 0 b = 0 For i = 0 To 255 a = (a + box(i) + Asc(Mid(strPwd, (i Mod Len(strPwd)) + 1, 1))) Mod 256 tempSwap = box(i) box(i) = box(a) box(a) = tempSwap Next RC4_init = boxEnd FunctionFunction MD5(strToHash) Dim tmpFile, strCommand, objFSO, objWshShell, out Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;) Set objWshShell = CreateObject(&quot;WScript.Shell&quot;) tmpFile = objFSO.GetSpecialFolder(2).Path &amp; &quot;\\&quot; &amp; objFSO.GetTempName objFSO.CreateTextFile(tmpFile).Write(strToHash) strCommand = &quot;certutil -hashfile &quot; &amp; tmpFile &amp; &quot; MD5&quot; out = objWshShell.Exec(strCommand).StdOut.ReadAll objFSO.DeleteFile tmpFile MD5 = Replace(Split(Trim(out), vbCrLf)(1), &quot; &quot;, &quot;&quot;)End FunctionFunction RC4(box, strData) Dim tempSwap Dim a Dim b Dim x Dim y Dim encryptedData encryptedData = &quot;&quot; For x = 1 To Len(strData) a = (a + 1) Mod 256 b = (b + box(a)) Mod 256 tempSwap = box(a) box(a) = box(b) box(b) = tempSwap y = Asc(Mid(strData, x, 1)) Xor box((box(a) + box(b)) Mod 256) encryptedData = encryptedData &amp; LCase(Right(&quot;0&quot; &amp; Hex(y), 2)) Next RC4 = encryptedDataEnd Functionmsgbox &quot;Do you know VBScript?&quot;msgbox &quot;VBScript (&quot;&quot;Microsoft Visual Basic Scripting Edition&quot;&quot;) is a deprecated Active Scripting language developed by Microsoft that is modeled on Visual Basic.&quot;msgbox &quot;It allows Microsoft Windows system administrators to generate powerful tools for managing computers without error handling and with subroutines and other advanced programming constructs. It can give the user complete control over many aspects of their computing environment.&quot;msgbox &quot;Interestingly, although VBScript has long since been deprecated, you can still run VBScript scripts on the latest versions of Windows 11 systems.&quot;msgbox &quot;A VBScript script must be executed within a host environment, of which there are several provided with Microsoft Windows, including: Windows Script Host (WSH), Internet Explorer (IE), and Internet Information Services (IIS).&quot;msgbox &quot;For .vbs files, the host is Windows Script Host (WSH), aka wscript.exe/cscript.exe program in your system.&quot;msgbox &quot;If you can not stop a VBScript from running (e.g. a dead loop), go to the task manager and kill wscript.exe/cscript.exe.&quot;msgbox &quot;cscript and wscript are executables for the scripting host that are used to run the scripts. cscript and wscript are both interpreters to run VBScript (and other scripting languages like JScript) on the Windows platform.&quot;msgbox &quot;cscript is for console applications and wscript is for Windows applications. It has something to do with STDIN, STDOUT and STDERR.&quot;msgbox &quot;OK! Now, let us begin our journey.&quot;key = InputBox(&quot;Enter the key:&quot;, &quot;CTF Challenge&quot;)if (key = False) then wscript.quitif (len(key)&lt;&gt;6) then wscript.echo &quot;wrong key length!&quot; wscript.quitend ifIf (MD5(key) = md5_key) Then wscript.echo &quot;You get the key!Move to next challenge.&quot;Else wscript.echo &quot;Wrong key!Try again!&quot; wscript.quitEnd IfuserInput = InputBox(&quot;Enter the flag:&quot;, &quot;CTF Challenge&quot;)if (userInput = False) then wscript.quitif (len(userInput)&lt;&gt;44) then wscript.echo &quot;wrong!&quot; wscript.quitend ifbox = RC4_init(key)encryptedInput = RC4(box, userInput)If (encryptedInput = enc_flag) Then MsgBox &quot;Congratulations! You have learned VBS!&quot;Else MsgBox &quot;Wrong flag. Try again.&quot;End Ifwscript.echo &quot;bye!&quot;&#x27; enc_flag = 0x59fc6b263c3d0fcbc331ade699e62d3473bbf85522d588e3423e6c751ca091528a3c0186e460483917192c14&#x27; md5(key) = baacc7ffa8232d28f814bb14c428798b RC4加密，key只有md5后的哈希，用hashcat爆破拿到key 解密： # ./hashcat.exe -a 3 -m 0 -d 1 &quot;baacc7ffa8232d28f814bb14c428798b&quot; ?a?a?a?a?a?adef rc4_decrypt(key, ciphertext): S = list(range(256)) j = 0 out = [] for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] i = j = 0 for char in ciphertext: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] out.append(char ^ S[(S[i] + S[j]) % 256]) return bytes(out)key = &#x27;H&amp;NKEY&#x27;ciphertext = bytes.fromhex(&#x27;59fc6b263c3d0fcbc331ade699e62d3473bbf85522d588e3423e6c751ca091528a3c0186e460483917192c14&#x27;)plaintext = rc4_decrypt(key.encode(), ciphertext)print(plaintext) H&amp;NCTF{VBS_1s_@_s0_7unny_an4_pow3rfu1_t00l!} hnwanna找到主函数，申清加密逻辑： 写解密代码： #include &lt;cstdio&gt;void a(char* input, int shift)&#123; char text[19]; printf(&quot;H&amp;NCTF&#123;&quot;); for(int i = 0; i &lt; 18; i++) &#123; if(input[i] &gt;= &#x27;a&#x27; &amp;&amp; input[i] &lt;= &#x27;z&#x27;) text[i] = ((char)(((int)(input[i] - &#x27;a&#x27;) + shift) % 26 + 97)); else text[i] += input[i]; printf(&quot;%c&quot;, text[i]); &#125; printf(&quot;&#125;&quot;);&#125;int main()&#123; char enc[] = &quot;justaeasyunitygame&quot;; int key = 5; a(enc, key); return 0;&#125; H&amp;NCTF{ozxyfjfxdzsnydlfrj} DO YOU KNOW SWDD?在异常处发现有SMC，找到SMC函数： 写IDC脚本解密： 得到加密函数： 解密： #include &lt;cstdio&gt;int main()&#123; char enc[] = &quot;S_VYFO_CGNN_GRKD_KLYED_IYE&quot;; int v4 = 10; printf(&quot;H&amp;NCTF&#123;&quot;); for(int i = 0; enc[i]; ++i) &#123; if(enc[i] &gt;= 65 &amp;&amp; enc[i] &lt;= 90) enc[i] = (enc[i] - v4 + 65) % 26 + 65; printf(&quot;%c&quot;, enc[i]); &#125; printf(&quot;&#125;&quot;); return 0;&#125;/*#include &lt;idc.idc&gt;static main()&#123; auto addr = 0x00417001; auto i = 0; auto j = 0; auto v5 = &quot;swdd&quot;; for(j = addr; j &lt; 0x0041815B; j++) PatchByte(j, Byte(j) ^ 4);&#125;*/ H&amp;NCTF{I_LOVE_SWDD_WHAT_ABOUT_YOU} 最喜欢的逆向题自己看图： H&amp;NCTF{Do_Y0u_like_F5_1n_Rev}","categories":[{"name":"比赛WP","slug":"比赛WP","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9BWP/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/tags/WriteUp/"}]},{"title":"敲响天堂之门","slug":"Reverse/Gate-of-Heaven","date":"2024-04-11T14:33:51.000Z","updated":"2024-07-07T05:42:07.821Z","comments":true,"path":"2024/04/11/Reverse/Gate-of-Heaven/","permalink":"http://example.com/2024/04/11/Reverse/Gate-of-Heaven/","excerpt":"","text":"“天堂之门”介绍：天堂之门技术（Heaven’s Gate）是依靠操作系统提供的在不同位数CPU进行跨架构的指令调用（SysWoW64），这使得32位和64位的指令环境可以放在同一个程序中，但是目前的调试器包括IDA在内很少有能跨架构调试的，这使得IDA的反汇编和调试都不能正常进行。 一个在动态调试层面恐怕是最有难度的逆向反调试 架构之间的切换：首先我们要知道32位寄存器cs的值是0x22，64位cs寄存器的值是0x33，我们将cs的值在这两者间切换，便达到了跨架构运行程序的目的。 那么我们如何更改寄存器cs的值呢？我们知道，mov指令是无法直接改变cs寄存器的值的，需要借助 call和 retf来实现cs段的切换 call far和retf(ret far)是可以同时改变cs和ip的： push 0x33 ;0x33作为cs的新值call $+5 ;下一条指令的地址入栈add dword [esp], 5 ;+5后即是指向retf的下一条指令retf ;跳转到下一条指令，同时pop is和pop cs 或者： jmp far 33:地址 这样就实现了将cs改为0x33的功能，即从32位跳转到64位。 对应的从64位跳转到32位的指令是： call $+5mov dword [rsp + 4], 0x23add dword [rsp], 0xDretf so，对cs的更改可以让程序在32位和64之间切换。 在32位编译器下： #include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;malloc.h&gt;int main()&#123; _asm &#123; _emit 0x6A // push 0x33 _emit 0x33 _emit 0xE8 // call $+5 _emit 0x05 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x83 // add dword [esp], 5 _emit 0x04 _emit 0x24 _emit 0x05 _emit 0xCB // retf &#125; printf(&quot;进入64位\\n&quot;); _asm &#123; _emit 0xE8 // call $+5 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0xC7 // mov dword [rsp + 4], 0x23 _emit 0x44 _emit 0x24 _emit 0x04 _emit 0x23 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x83 // add dword [rsp], 0xD _emit 0x04 _emit 0x24 _emit 0x0D _emit 0xCB // retf &#125; printf(&quot;回到32位\\n&quot;); return 0;&#125; 在64位编译器下： _asm &#123;_emit 0x6A_emit 0x33 _emit 0xE8 _emit 0x05_emit 0x00_emit 0x00_emit 0x00_emit 0x83 _emit 0x04 _emit 0x24 _emit 0x05 _emit 0xCB &#125; _asm &#123;_emit 0x6A_emit 0x23 //改成0x23 _emit 0xE8 _emit 0x05_emit 0x00_emit 0x00_emit 0x00_emit 0x83 _emit 0x04 _emit 0x24 _emit 0x05 _emit 0xCB &#125; 64位编译器下只能用这个方法跳转，原因暂时未知。 push 0x33 ;转32位就用0x23call $+5add dword [esp], 5retf 未完待续…","categories":[{"name":"Reverse","slug":"Reverse","permalink":"http://example.com/categories/Reverse/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"}]},{"title":"MRCTF2020 VirtualTree（花指令+动态调试）","slug":"Reverse/VirtualTree","date":"2024-04-10T14:27:36.000Z","updated":"2024-04-11T13:11:36.569Z","comments":true,"path":"2024/04/10/Reverse/VirtualTree/","permalink":"http://example.com/2024/04/10/Reverse/VirtualTree/","excerpt":"","text":"[MRCTF2020]VirtualTree（花指令+动态调试）32位无壳，放进IDA里，main函数很清晰， 试着恢复一下符号表： 看一下key的调用，找到更改key值的函数， 结合题目，可以看出这是一个二叉树，搞一个结构体： 回头看第一个加密函数： 就是把key中的数据根input一个一个异或，比较简单， 把input搞成0，动调可以搞到key的数据 key = &quot;MLGPOKFCJENIHDBA&quot; 再分析enc2:，有花指令，比较容易去掉： 去掉后里面的加密函数是这样： 逆向这个函数解密后发现根本解不出来，动调一下试试： 动调后发现这些函数全被更改了，汇编是这样的： call的那些函数是对input执行了一些简单的更改。 汇编： .text:004216F0 push ebp.text:004216F1 mov ebp, esp.text:004216F3 push 0Ah.text:004216F5 push 0.text:004216F7 mov eax, offset func_add.text:004216FC call eax ; loc_421510 //input[0] += 10.text:004216FC.text:004216FE add esp, 8.text:00421701 push 2.text:00421703 push 1.text:00421705 mov eax, offset func_xor.text:0042170A call eax ; loc_421510 //input[1] ^= input[2].text:0042170A.text:0042170C add esp, 8.text:0042170F push 7.text:00421711 push 2.text:00421713 mov eax, offset func_add.text:00421718 call eax ; loc_421510 //input[2] += 7.text:00421718.text:0042171A add esp, 8.text:0042171D push 7.text:0042171F push 3.text:00421721 mov eax, offset func_sub.text:00421726 call eax ; loc_421510 //input[3] = abs(input[3] - input[7]).text:00421726.text:00421728 add esp, 8.text:0042172B push 5.text:0042172D push 4.text:0042172F mov eax, offset func_xor.text:00421734 call eax ; loc_421510 //input[4] ^= input[5].text:00421734.text:00421736 add esp, 8.text:00421739 push 1.text:0042173B push 6.text:0042173D mov eax, offset func_sub.text:00421742 call eax ; loc_421510 //input[6] = abs(input[6] - input[1]).text:00421742.text:00421744 add esp, 8.text:00421747 push 3.text:00421749 push 7.text:0042174B mov eax, offset func_add.text:00421750 call eax ; loc_421510 //input[7] += 3.text:00421750.text:00421752 add esp, 8.text:00421755 push 7.text:00421757 push 8.text:00421759 mov eax, offset func_xor.text:0042175E call eax ; loc_421510 //input[8] ^= input[7].text:0042175E.text:00421760 add esp, 8.text:00421763 push 8.text:00421765 push 9.text:00421767 mov eax, offset func_sub.text:0042176C call eax ; loc_421510 //input[9] = abs(input[9] - input[8]).text:0042176C.text:0042176E add esp, 8.text:00421771 push 7.text:00421773 push 0Ah.text:00421775 mov eax, offset func_sub.text:0042177A call eax ; loc_421510 //input[10] = abs(input[10] - input[7]).text:0042177A.text:0042177C add esp, 8.text:0042177F push 0Ch.text:00421781 push 0Bh.text:00421783 mov eax, offset func_xor.text:00421788 call eax ; loc_421510 //input[11] ^= input[12].text:00421788.text:0042178A add esp, 8.text:0042178D push 2.text:0042178F push 0Ch.text:00421791 mov eax, offset func_sub.text:00421796 call eax ; loc_421510 //input[12] = abs(input[12] - input[2]).text:00421796.text:00421798 add esp, 8.text:0042179B push 0Fh.text:0042179D push 0Eh.text:0042179F mov eax, offset func_xor.text:004217A4 call eax ; loc_421510 //input[14] ^= input[15].text:004217A4.text:004217A6 add esp, 8.text:004217A9 push 2.text:004217AB push 0Fh.text:004217AD mov eax, offset func_add.text:004217B2 call eax ; loc_421510 //input[15] += 2.text:004217B2.text:004217B4 add esp, 8.text:004217B7 nop.text:004217B8 nop.text:004217B9 pop ebp.text:004217BA retn 写解密代码： input = [0x17, 0x63, 0x77, 0x03, 0x52, 0x2E, 0x4A, 0x28, 0x52, 0x1B, 0x17, 0x12, 0x3A, 0x0A, 0x6C, 0x62]def add(a, b): input[a] -= bdef xor(a, b): input[a] ^= input[b]def sub(a, b): # maybe_input1.append(input[a] + input[b]) # maybe_input2.append(input[b] - input[a]) input[a] = abs(input[a] - input[b]) # 因为abs有两种可能性，全取这种可能得到的flag最正常key = &quot;MLGPOKFCJENIHDBA&quot;opcode = [1, 2, 1, 3, 2, 3, 1, 2, 3, 3, 2, 3, 2, 1] # 1表示加密中的add, 2表示xor, 3表示suba1 = [0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 14, 15] # 第一个参数a2 = [10, 2, 7, 7, 5, 1, 3, 7, 8, 7, 12, 2, 15, 2] # 第二个参数for i in range(13, -1, -1): if opcode[i] == 1: add(a1[i], a2[i]) elif opcode[i] == 2: xor(a1[i], a2[i]) elif opcode[i] == 3: sub(a1[i], a2[i])for i in range(16): input[i] ^= ord(key[i])for i in input: print(chr(i), end = &#x27;&#x27;) 得到flag： MRCTF{@_7r3e_f0r_fuNN!}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"http://example.com/categories/Reverse/"}],"tags":[{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"去OLLVM平坦化([SUCTF2019]hardCPP)","slug":"Reverse/LLVM","date":"2024-03-26T14:46:39.000Z","updated":"2024-04-11T13:53:32.020Z","comments":true,"path":"2024/03/26/Reverse/LLVM/","permalink":"http://example.com/2024/03/26/Reverse/LLVM/","excerpt":"","text":"去OLLVM平坦化([SUCTF2019]hardCPP)用ida打开是这样 十分有十二分的平坦化痕迹， 上次强网杯遇到过，但是因为当时没装好环境，deflat.py跑不出来，遗憾放弃。 这次又碰见不想再回避，打开这个网址把脚本装下来，https://github.com/Pure-T/deflat，看readme，要先装一个angr库（这个库在做VM虚拟机类题，写解析器脚本的时候也会很有用，以后可能再写） pip install angr 下载时间可能会有点长， 官方说的是用8.19.4.5版本，实际较新版本依然可用， 装好后用以下指令去平坦化： python deflat.py hardCpp 0x4007E0 #python + deflat.py + 文件名 + 起始地址(基本就是main函数的地址) 然而出错： 回看readme， 下载那个graph.py然后改名为am_graph.py ，将其与deflat.py放在同一目录下， 再次运行相同命令： python deflat.py hardCpp 0x4007E0 #python + deflat.py + 文件名 + 起始地址(基本就是main函数的地址) 期间可能会出现大量类似警告： 不要害怕，只要最后是这样就好： 将recovered的文件再放进ida里面看： 成功！ 下面就是逆向环节了也有部分去平坦化操作 首先排除上面这两个循环有用， 看到这一坨函数不要怕，其实就是c++里面的奇奇怪怪的东西（好像叫lambda表达式），来看看他们到底是干嘛的， 在对各函数分析的过程中发现在0x401310、0x4014E0和0x4016C0依然有平坦化，再跑脚本去一下， python deflat.py hardCpp_recovered 0x401310 0x401310： 再跑一遍 python deflat.py hardCpp_recovered_recovered 0x4016C0 0x4016C0： 再跑一遍： python deflat.py hardCpp_recovered_recovered_recovered 0x4014E0 0x4014E0： 得到hardCPP_recovered_recovered_recovered_recovered 这次再放进ida并改名： 接下来就是搞清func1、func2、func3的功能： 其中两个就是是return第二个数据，另一个是add， 把这几个函数简化成表达式： 是不是已经非常清晰了！ 整理一下： v18 = (3 * (18 ^ input[i - 1 + v21]) + 2) ^ ((v21 ^ input[i]) + (input[i - 1 + v21] % 7)) 从前面看出：v21大概是0 （真的是大概，当时我也不太确定） 然后等式左边的v18就是enc[i]那么这个算法显然可逆： 把函数开头的md5解密一下： 那么flag（input）的第一位是‘#’ 好了可以写解密代码了： enc = [0xF3, 0x2E, 0x18, 0x36, 0xE1, 0x4C, 0x22, 0xD1, 0xF9, 0x8C, 0x40, 0x76, 0xF4, 0x0E, 0x00, 0x05, 0xA3, 0x90, 0x0E, 0xA5]input = &#x27;#&#x27;k = len(input)for j in range(len(enc)): input += chr(((enc[j] ^ ((ord(input[j]) ^ 18) * 3 + 2)) - (ord(input[j]) % 7)) &amp; 0xff)print(input) flag： flag{mY-CurR1ed_Fns}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"http://example.com/categories/Reverse/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"},{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"浅谈VM虚拟机","slug":"Reverse/aboutvm","date":"2024-03-26T14:43:22.000Z","updated":"2024-04-14T08:09:33.551Z","comments":true,"path":"2024/03/26/Reverse/aboutvm/","permalink":"http://example.com/2024/03/26/Reverse/aboutvm/","excerpt":"","text":"浅谈VM虚拟机1. 什么是虚拟机？ 虚拟机：自己定义一套指令，在程序中能有一套函数和结构解释自己定义的指令并执行功能。 查一下维基百科 虚拟机（英语：virtual machine），在计算机科学中的体系结构里，是指一种特殊的软件，可以在计算机平台和终端用户之间创建一种环境，而终端用户则是基于虚拟机这个软件所创建的环境来操作其它软件。虚拟机（VM）是计算机系统的仿真器，通过软件模拟具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统，能提供物理计算机的功能。 有不同种类的虚拟机，每种虚拟机具有不同的功能： 系统虚拟机（也称为全虚拟化虚拟机）可代替物理计算机。它提供了运行整个操作系统所需的功能。虚拟机监视器（hypervisor）共享和管理硬件，从而允许有相互隔离但存在于同一物理机器上的多个环境。现代虚拟机监视器使用虚拟化专用硬件（主要是主机CPU）来进行硬件辅助虚拟化。 程序虚拟机 被设计用来在与平台无关的环境中执行计算机程序。 而我们CTF中遇到的虚拟机一般是这种： vm（虚拟机保护）是一种基于虚拟机的代码保护技术。他将基于x86汇编系统中的可执行代码转换为字节码指令系统的代码。来达到不被轻易篡改和逆向的目的。 2. 虚拟机的运行原理要搞清虚拟机的运行原理，最好的方法是手搓一个虚拟机出来： 一般虚拟机分为基于寄存器的虚拟机和基于栈的虚拟机，通过数据存储处理的方式区分，二者的区别可以看这里 栈式虚拟机和寄存器式虚拟机？ 这里先写一个简单的寄存器虚拟机， 实现虚拟机时，要做好这么几个步骤： 寄存器虚拟机需要初始化好栈空间和寄存器空间 定义一套opcode 实现opcode功能的模块 定义opcode和寄存器： enum regist&#123; R1 = 0xe1, R2 = 0xe2, R3 = 0xe3,&#125;;enum opcodes&#123; MOV = 0xf1, XOR = 0xf2, RET = 0xf4, READ = 0xf5,&#125;; 定义vm相关变量： typedef struct&#123; unsigned char opcode; void (*handle)(void*); //handler执行器&#125;vm_opcode;typedef struct vm_cpus&#123; int r1; int r2; int r3; unsigned char* eip; //指向opcode的指针 vm_opcode op_list[OPCODE_N]; //opcode列表，存储opcode和其对应的操作函数&#125;vm_cpu; 初始化vm各项数据，并使opcode关联handler功能函数 void vm_init(vm_cpu* cpu)&#123; cpu-&gt;r1 = 0; cpu-&gt;r2 = 0; cpu-&gt;r3 = 0; cpu-&gt;eip = (unsigned char*)vm_code; cpu-&gt;op_list[0].opcode = 0xf1; cpu-&gt;op_list[0].handle = (void (*)(void*))mov; //0xf1对应mov cpu-&gt;op_list[1].opcode = 0xf2; cpu-&gt;op_list[1].handle = (void (*)(void*))xor1; //0xf2对应xor cpu-&gt;op_list[2].opcode = 0xf5; cpu-&gt;op_list[2].handle = (void (*)(void*))read1; //0xf1对应read vm_stack = (char*)malloc(0x512); memset(vm_stack, 0, 0x512); //开辟栈空间&#125; vm启动函数： void vm_start(vm_cpu* cpu)&#123; cpu-&gt;eip = (unsigned char*)vm_code; while((*cpu-&gt;eip) != RET) //持续执行opcode直到ret vm_dispatcher(cpu);&#125; 执行器： void vm_dispatcher(vm_cpu* cpu)&#123; for(int i = 0; i &lt; OPCODE_N; i++) if(*cpu-&gt;eip == cpu-&gt;op_list[i].opcode) &#123; cpu-&gt;op_list[i].handle(cpu); break; &#125;&#125; 再写出opcode： unsigned char vm_code[] = &#123; 0xf5, 0xf1,0xe1,0x0,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x0,0x00,0x00,0x00, 0xf1,0xe1,0x1,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x1,0x00,0x00,0x00, 0xf1,0xe1,0x2,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x2,0x00,0x00,0x00, 0xf1,0xe1,0x3,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x3,0x00,0x00,0x00, 0xf1,0xe1,0x4,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x4,0x00,0x00,0x00, 0xf1,0xe1,0x5,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x5,0x00,0x00,0x00, 0xf1,0xe1,0x6,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x6,0x00,0x00,0x00, 0xf1,0xe1,0x7,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x7,0x00,0x00,0x00, 0xf1,0xe1,0x8,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x8,0x00,0x00,0x00, 0xf1,0xe1,0x9,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x9,0x00,0x00,0x00, 0xf1,0xe1,0xa,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xa,0x00,0x00,0x00, 0xf1,0xe1,0xb,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xb,0x00,0x00,0x00, 0xf1,0xe1,0xc,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xc,0x00,0x00,0x00, 0xf1,0xe1,0xd,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xd,0x00,0x00,0x00, 0xf1,0xe1,0xe,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xe,0x00,0x00,0x00, 0xf1,0xe1,0xf,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xf,0x00,0x00,0x00, 0xf1,0xe1,0x10,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x10,0x00,0x00,0x00, 0xf1,0xe1,0x11,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x11,0x00,0x00,0x00, 0xf1,0xe1,0x12,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x12,0x00,0x00,0x00, 0xf1,0xe1,0x13,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x13,0x00,0x00,0x00, 0xf1,0xe1,0x14,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x14,0x00,0x00,0x00, 0xf1,0xe1,0x15,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x15,0x00,0x00,0x00, 0xf1,0xe1,0x16,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x16,0x00,0x00,0x00, 0xf1,0xe1,0x17,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x17,0x00,0x00,0x00, 0xf1,0xe1,0x18,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x18,0x00,0x00,0x00, 0xf1,0xe1,0x19,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x19,0x00,0x00,0x00, 0xf4&#125;; 寄存器虚拟机完成。 3. 给个实例，出个小题上面的虚拟机大概实现的就是这个过程 call read1MOV R1,flag[i]XOR R1 0x12MOV [OFFEST],R1; //循环len(flag)次ret 也就是实现了 for(int i = 0; i &lt; strlen(flag); i++) flag[i] ^= 0x12; 的功能。 把源码放在这： maybeVM 4. 如何破解VM虚拟机保护类题目 解题一般步骤： 分析VM结构-&gt;分析opcode-&gt;编写parser-&gt;re算法 VM结构常见类型： 基于栈、基于队列、基于信号量 opcode： 与VM数据结构对应的指令 ：push pop 运算指令：add、sub、mul等 示例1链接：[NewStarCTF 2023 公开赛道]茶 用来简单了解VM原理 ——by me 示例2链接：[watevrCTF 2019]Repyc——WriteUp pyc+混淆+VM虚拟机 ——by me","categories":[{"name":"Reverse","slug":"Reverse","permalink":"http://example.com/categories/Reverse/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"},{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]}],"categories":[{"name":"比赛WP","slug":"比赛WP","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9BWP/"},{"name":"Reverse","slug":"Reverse","permalink":"http://example.com/categories/Reverse/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/tags/WriteUp/"},{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"},{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]}