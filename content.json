{"meta":{"title":"Pinguw's Blog","subtitle":"","description":"","author":"Pinguw","url":"https://Pinguw.github.io","root":"/"},"pages":[{"title":"关于博主","date":"2024-06-02T15:26:14.725Z","updated":"2024-06-02T15:26:14.725Z","comments":true,"path":"aboutme.html","permalink":"https://pinguw.github.io/aboutme.html","excerpt":"","text":"小时候打喷嚏，总觉得是谁在偷偷想自己。现在看来，说不定是长大的自己在想念小时候的自己。 2023年8月 - 刚得知自己考上大学就稀里糊涂地被拉去打了新生赛。（那时候的我还不知道自己已经踏上了一条不归路） 2023年10月 - 新生赛的征程结束，大家都各自选好了自己的方向，即使到现在我也不知为何会选择在逆向上走下去。我队已经3年没人做逆向了，不妨把这算作一条理由罢。 2023年11月 - 首次参加企业比赛HWS，虽然最后的奖金只有300米，但也是一次极棒的体验和学习经历。 2024年3月 - 我大抵是完全放弃了深造下去的念头。唉，但是谁不想读研啊，我也想学习啊。。。 2024年4月13日 - 校赛，其中五道逆向，斩获四道一血，一道二血，算是不负众望吧。 2024年4月 - Pinguw加入HASHTEAM！！！ 2024年4月17日 - 跟着其他队员首次接触到AWD模式，然鹅只有挨打的份。说实话，即使是什么也不会（只能改个弱口令），也能真切地感受到这个比赛模式的紧张与刺激。也是，AWD里，逆向手又能做什么呢？ 2024年4月21日 - 成功加入山东大学镜像站，负责后端开发。第一个任务是…五一前把现在的后端看完。 2024年5月13日 - 带队拿到首奖，大家辛苦了（补一句：社工真好玩，社不出来不好玩）。 2024年5月18日、19日 - 首次CISCN（CTF国赛），承担了全队的re出题，虽然水平还是不够，但还是够得上各方向的平均数吧。 2024年6月2日 - Pinguw加入Nepnep！！！"},{"title":"文章归档","date":"2024-04-11T13:54:27.378Z","updated":"2024-04-11T13:54:27.378Z","comments":true,"path":"archives.html","permalink":"https://pinguw.github.io/archives.html","excerpt":"","text":""},{"title":"赞助我","date":"2024-06-05T07:44:12.737Z","updated":"2024-06-05T07:44:12.737Z","comments":true,"path":"donate.html","permalink":"https://pinguw.github.io/donate.html","excerpt":"","text":"不必赞助我了，把钱留给自己和父母吧，先学会对自己好，也要记得及时报养育之恩。 赞助单感谢施主大恩大德！ 时间 捐助人 金额 留言 2024-6-5 yujia 0.5 V你50"},{"title":"我的朋友","date":"2024-06-07T08:18:46.235Z","updated":"2024-06-07T08:18:46.235Z","comments":true,"path":"friends.html","permalink":"https://pinguw.github.io/friends.html","excerpt":"","text":"我们会慢慢长大成人，随着季节的不停变换路边盛开的鲜花也在不断变化，那个季节盛开的鲜花到底叫什么名字，轻轻摇曳着一旦触摸它就会轻轻地被扎到，用鼻子靠近闻一闻，会有一股淡淡的青涩太阳的芳香，随着那股香味慢慢变淡我们也在长大成人，但是那朵花一定会在某处继续盛开。 朋友们每次编译时，随机排序"},{"title":"","date":"2024-06-03T08:07:26.436Z","updated":"2024-06-03T08:07:26.436Z","comments":true,"path":"diary/2024年第一份月报.html","permalink":"https://pinguw.github.io/diary/2024%E5%B9%B4%E7%AC%AC%E4%B8%80%E4%BB%BD%E6%9C%88%E6%8A%A5.html","excerpt":"","text":"先说总结：前半个月很闲，后半个月忙飞，但是收获满满的一个月！5.1-5.5刚从失落中逃出来，恰好是五一可以休整一下。原本也是没想回家的，但爸妈来青玩，顺便也给我接回去。 看一下五一山青旁边的滨海公园： 回家后没什么好说的，睡觉+打游戏循环，偶尔被拉过去打打工做几道re。 当然，做做水题罢了，遇到难题直接开摆。 get到一个新游戏，永劫真好玩。 5.9放完假回来更不想上课了，今天实在困得不行连从不敢逃的高数都不去上了。（又打了一天劫） 明天是校运会，冲掉了一天课，本来想着去济南，可惜朋友很忙没空带我转转，有机会再去。 5.12-5.19中间断更的几天没什么好写的，就是上班+打劫。 然后就是比赛、比赛、比赛，无休止的比赛，我还以为上课打H&amp;N已经够离谱了，没想到这两天的国赛强度更大，先不说做不做得出来，就是搁那坐着不能看QQ就挺折磨了。 5.22高数老师换成之前那个不点名的了，现在平均每周两三节课了（ 上课是不可能上课的，反正都是突击复习一下就能过的东西，学好了说实话也没什么用。 5.26-5.27京麒+RCTF+DragonKnightCTF+上海磐石（没打）四联，什么CTF期末周。 听王师傅的话，给Nepnep投了个简历。 6.2虽然DASCTF爆零了，但是收到了好消息： 经历两轮面试，终于 成功加入Nepnep！ 但现在回头看，算是比较平常的一个月。"},{"title":"","date":"2024-08-26T07:00:31.554Z","updated":"2024-08-26T07:00:17.194Z","comments":true,"path":"diary/2024年第二份月报.html","permalink":"https://pinguw.github.io/diary/2024%E5%B9%B4%E7%AC%AC%E4%BA%8C%E4%BB%BD%E6%9C%88%E6%8A%A5.html","excerpt":"","text":""}],"posts":[{"title":"KCTF2024第四题-神秘信号 & PVM注入","slug":"Reverse/KCTF2024-4","date":"2024-09-14T09:19:22.000Z","updated":"2024-09-14T11:48:15.339Z","comments":true,"path":"2024/09/14/Reverse/KCTF2024-4/","permalink":"https://pinguw.github.io/2024/09/14/Reverse/KCTF2024-4/","excerpt":"","text":"跟Nep打KCTF的时候遇上了一个能帮得上忙的题，正好前几天学了一个py逆向的小技巧，现在发挥作用了。 KCTF2024第四题-神秘信号先解包后反编译main.py： 1234567891011121314151617181920212223#!/usr/bin/env python# visit https://tool.lu/pyc/ for more information# Version: Python 3.8import CrackMeprint(&#x27;(账号密码由字母大小写、数字、!、空格组成)&#x27;)print(&#x27;请输入账号：&#x27;)h = input()z = CrackMe.main(h)if len(z) &lt; 20: key = &#x27;dZpKdrsiB6cndrGY&#x27; + zelse: key = z[0:4] + &#x27;dZpK&#x27; + z[4:8] + &#x27;drsi&#x27; + z[8:12] + &#x27;B6cn&#x27; + z[12:16] + &#x27;drGY&#x27; + z[16:]print(&#x27;请输入验证码：&#x27;)h = input()m = CrackMe.main(h)if key == m: print(&#x27;Success&#x27;)print(&#x27;Fail&#x27;)continuecontinue 看得出来核心逻辑在CrackMe的main模块里， 但是直接翻解包出来的文件没有找到CrackMe的踪影。 用上面的方法注入一下代码看一下CrackMe的属性： 1234567# code.pyprint(&quot;===============================================&quot;)print(dir(CrackMe))print(&quot;===============================================&quot;) 没有__file__属性，说明可能是一个动态生成的模块， 试试直接dump main： 12345print(&quot;===============================================&quot;)print(dir(CrackMe.main.__code__))print(&quot;===============================================&quot;) 有__code__属性，直接dump： 123456789101112131415161718import marshalimport importlibprint(&quot;===============================================&quot;)print(dir(CrackMe.main.__code__))code1 = CrackMe.main.__code__open(&quot;dumped_main.marshal&quot;, &quot;wb&quot;).write(marshal.dumps(code1))with open(&quot;dumped_main.marshal&quot;, &quot;rb&quot;) as f: code = marshal.load(f)pyc_data = importlib._bootstrap_external._code_to_timestamp_pyc(code)with open(&quot;file_main.pyc&quot;, &quot;wb&quot;) as f: f.write(pyc_data)print(&quot;===============================================&quot;) 成功： 逆一下逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def encode(data): encoded_str = &#x27;&#x27; padding = 0 base64_chars = &#x27;ZQ+U7tSBEKVzyf5coCwb94Dd6raT0eLNin12Hp8mOxFuvMgIPlhRY3WjksqJAXG/&#x27; ww = b&#x27;&#x27; for i in data: i = i ^ 85 ww = ww + i.to_bytes(1, &#x27;little&#x27;) data = ww for i in range(0, len(data), 3): chunk = data[i:i + 3] binary_str = &#x27;&#x27;.join(format(byte, &#x27;08b&#x27;) for byte in chunk) for j in range(0, len(binary_str), 6): six_bits = binary_str[j:j + 6] if len(six_bits) &lt; 6: padding += 6 - len(six_bits) six_bits += &#x27;0&#x27; * (6 - len(six_bits)) encoded_str += base64_chars[int(six_bits, 2)] encoded_str += &#x27;!&#x27; * (padding // 2) for i in range(len(encoded_str) // 2): a = encoded_str[i * 2] b = encoded_str[i * 2 + 1] encoded_str = encoded_str[:i * 2] + b + a + encoded_str[i * 2 + 2:] return encoded_strdef decode(encoded_str): base64_chars = &#x27;ZQ+U7tSBEKVzyf5coCwb94Dd6raT0eLNin12Hp8mOxFuvMgIPlhRY3WjksqJAXG/&#x27; decoded_str = list(encoded_str) for i in range(len(decoded_str) // 2): a = decoded_str[i * 2] b = decoded_str[i * 2 + 1] decoded_str[i * 2], decoded_str[i * 2 + 1] = b, a decoded_str = &#x27;&#x27;.join(decoded_str) padding = decoded_str.count(&#x27;!&#x27;) decoded_str = decoded_str.rstrip(&#x27;!&#x27;) binary_str = &#x27;&#x27; for char in decoded_str: binary_str += format(base64_chars.index(char), &#x27;06b&#x27;) if padding: binary_str = binary_str[:-padding] decoded_bytes = bytearray() for i in range(0, len(binary_str), 8): byte = binary_str[i:i + 8] decoded_bytes.append(int(byte, 2)) original_data = bytearray() for byte in decoded_bytes: original_data.append(byte ^ 85) return original_data 回头看一下，这个encode函数，传入的参数data类型是bytes，但是main.py调用的时候传递的是str， 先模拟一下main中的输入输出， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465def encode(data): encoded_str = &#x27;&#x27; padding = 0 base64_chars = &#x27;ZQ+U7tSBEKVzyf5coCwb94Dd6raT0eLNin12Hp8mOxFuvMgIPlhRY3WjksqJAXG/&#x27; ww = b&#x27;&#x27; for i in data: i = i ^ 85 ww = ww + i.to_bytes(1, &#x27;little&#x27;) data = ww for i in range(0, len(data), 3): chunk = data[i:i + 3] binary_str = &#x27;&#x27;.join(format(byte, &#x27;08b&#x27;) for byte in chunk) for j in range(0, len(binary_str), 6): six_bits = binary_str[j:j + 6] if len(six_bits) &lt; 6: padding += 6 - len(six_bits) six_bits += &#x27;0&#x27; * (6 - len(six_bits)) encoded_str += base64_chars[int(six_bits, 2)] encoded_str += &#x27;!&#x27; * (padding // 2) for i in range(len(encoded_str) // 2): a = encoded_str[i * 2] b = encoded_str[i * 2 + 1] encoded_str = encoded_str[:i * 2] + b + a + encoded_str[i * 2 + 2:] return encoded_strdef decode(encoded_str): base64_chars = &#x27;ZQ+U7tSBEKVzyf5coCwb94Dd6raT0eLNin12Hp8mOxFuvMgIPlhRY3WjksqJAXG/&#x27; decoded_str = list(encoded_str) for i in range(len(decoded_str) // 2): a = decoded_str[i * 2] b = decoded_str[i * 2 + 1] decoded_str[i * 2], decoded_str[i * 2 + 1] = b, a decoded_str = &#x27;&#x27;.join(decoded_str) padding = decoded_str.count(&#x27;!&#x27;) decoded_str = decoded_str.rstrip(&#x27;!&#x27;) binary_str = &#x27;&#x27; for char in decoded_str: binary_str += format(base64_chars.index(char), &#x27;06b&#x27;) if padding: binary_str = binary_str[:-padding] decoded_bytes = bytearray() for i in range(0, len(binary_str), 8): byte = binary_str[i:i + 8] decoded_bytes.append(int(byte, 2)) original_data = bytearray() for byte in decoded_bytes: original_data.append(byte ^ 85) return original_datah = b&#x27;D7C4197AF0806891&#x27;z = encode(h)if len(z) &lt; 20: key = &#x27;dZpKdrsiB6cndrGY&#x27; + zelse: key = z[0:4] + &#x27;dZpK&#x27; + z[4:8] + &#x27;drsi&#x27; + z[8:12] + &#x27;B6cn&#x27; + z[12:16] + &#x27;drGY&#x27; + z[16:]print(key)# print(z)w = &#x27;D7CHel419lo 7AFWor080ld!6891&#x27;x = encode(w.encode())print(x) 发现给的标准输入输出结果对不起来， 那么在main中还有哪里可能做修改呢？ 只能是input() 输出一下input()后的值： 看起来是将可见输入做了一个映射，打印一下映射表： 解密代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283def encode(data): encoded_str = &#x27;&#x27; padding = 0 base64_chars = &#x27;ZQ+U7tSBEKVzyf5coCwb94Dd6raT0eLNin12Hp8mOxFuvMgIPlhRY3WjksqJAXG/&#x27; ww = b&#x27;&#x27; for i in data: i = i ^ 85 ww = ww + i.to_bytes(1, &#x27;little&#x27;) data = ww for i in range(0, len(data), 3): chunk = data[i:i + 3] binary_str = &#x27;&#x27;.join(format(byte, &#x27;08b&#x27;) for byte in chunk) for j in range(0, len(binary_str), 6): six_bits = binary_str[j:j + 6] if len(six_bits) &lt; 6: padding += 6 - len(six_bits) six_bits += &#x27;0&#x27; * (6 - len(six_bits)) encoded_str += base64_chars[int(six_bits, 2)] encoded_str += &#x27;!&#x27; * (padding // 2) for i in range(len(encoded_str) // 2): a = encoded_str[i * 2] b = encoded_str[i * 2 + 1] encoded_str = encoded_str[:i * 2] + b + a + encoded_str[i * 2 + 2:] return encoded_strdef decode(encoded_str): base64_chars = &#x27;ZQ+U7tSBEKVzyf5coCwb94Dd6raT0eLNin12Hp8mOxFuvMgIPlhRY3WjksqJAXG/&#x27; decoded_str = list(encoded_str) for i in range(len(decoded_str) // 2): a = decoded_str[i * 2] b = decoded_str[i * 2 + 1] decoded_str[i * 2], decoded_str[i * 2 + 1] = b, a decoded_str = &#x27;&#x27;.join(decoded_str) padding = decoded_str.count(&#x27;!&#x27;) decoded_str = decoded_str.rstrip(&#x27;!&#x27;) binary_str = &#x27;&#x27; for char in decoded_str: binary_str += format(base64_chars.index(char), &#x27;06b&#x27;) if padding: binary_str = binary_str[:-padding] decoded_bytes = bytearray() for i in range(0, len(binary_str), 8): byte = binary_str[i:i + 8] decoded_bytes.append(int(byte, 2)) original_data = bytearray() for byte in decoded_bytes: original_data.append(byte ^ 85) return original_dataa1 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;b1 = b&#x27;KJIHGFETSRQPONM&lt;;:98765DCB&#x27;.decode(&#x27;latin1&#x27;)a2 = &quot;abcdefghijklmnopqrstuvwxyz&quot;b2 = b&quot;+*)(\\&#x27;&amp;%43210/.-\\x1c\\x1b\\x1a\\x19\\x18\\x17\\x16\\x15$#\\&quot;&quot;.decode(&#x27;latin1&#x27;)a3 = &quot;0123456789 !&quot;b3 = b&#x27;\\\\[ZYXWVUdclk&#x27;.decode(&#x27;latin1&#x27;)a = a1 + a2 + a3b = b1 + b2 + b3table1 = str.maketrans(a, b)table2 = str.maketrans(b, a)data = &quot;KCTF&quot;enc_data = data.translate(table1)z = encode(enc_data.encode(&#x27;latin1&#x27;))if len(z) &lt; 20: key = &#x27;dZpKdrsiB6cndrGY&#x27; + zelse: key = z[0:4] + &#x27;dZpK&#x27; + z[4:8] + &#x27;drsi&#x27; + z[8:12] + &#x27;B6cn&#x27; + z[12:16] + &#x27;drGY&#x27; + z[16:]print(decode(key))encode_key = decode(key)encode_key = encode_key.decode(&#x27;latin1&#x27;)flag = encode_key.translate(table2)print(flag) Hello World!KCTF PVM注入前置知识目前来看的python逆向常见题型有：逆pyc和逆pyd； 先说逆pyd， .pyd 文件是 Windows 平台上的 Python 动态加载模块（Dynamic Load Module）。它与 Linux 和 macOS 平台上的 .so 文件类似，都是用于扩展 Python 的功能的二进制文件。 一般的pyd是用Cython编译出的二进制文件，这东西是基本不可逆的。 逆pyc的类型就比较多了，有直接给pyc的，有打包成exe的，有只给pyc字节码的，这三种本质上没什么区别，毕竟pyc是可以反编译成py文件，难点就在于去花指令和去混淆上。 什么是PVM注入注入原理首先要清楚Python代码执行的原理，主要步骤就是CPython把py代码编译成字节码，然后在Python虚拟机（PVM）中执行， 我们先了解一下Python中的GIL： GIL 是 Python 中的全局解释器锁（Global Interpreter Lock）的缩写。它是 Python 解释器（特别是 CPython 实现）中的一个机制，用于在多线程环境下保护访问 Python 对象的内存管理和执行。 而CPython实际上是有一些执行接口的，我们可以取得GIL后创建线程，就可以在Python虚拟机中执行Python代码了，实现如下： 12345Py_SetProgramName(L&quot;main.py&quot;); // 当前Python程序名PyEval_InitThreads();PyGILState_STATE s = PyGILState_Ensure();PyRun_SimpleString(&quot;print(&#x27;hello world&#x27;)&quot;); // 执行python代码PyGILState_Release(s); 对Python虚拟机的注入在github有现成的项目：https://github.com/call-042PE/PyInjector/ 他的使用也非常简单，把名为code.py的文件与需要注入的程序放在同一文件夹下即可，code.py的内容就是注入执行的代码。 注入示例我们写一个简单的test.py： 123456def print_1(name): print(&quot;Hello, &quot; + name + &quot;!&quot;)if __name__ == &quot;__main__&quot;: name = input(&quot;What is your name?\\n&quot;) print_1(name) 用pyinstaller打包成exe并执行： 从PyInjector项目中安装好注入用的dll，再编写一下code.py： 1print(print_1(&quot;hacker&quot;)) 运行test.exe并等待输入， 用Process Hacker找到正在运行的test.exe进程： 注入dll： 选择对应架构的dll： 可以看到成功注入： pyc字节码dump我们知道pyc文件实际上就是文件头 + code object，code object就是代码对象，用于表示编译后的字节码的数据结构。 我们可以注入Python虚拟机，然后得到代码对象，就可以得到代码逻辑了。 从Doctor3师傅的博客中我们知道可以如下dump出exe中的pyc文件： 123456789101112131415161718import sys, marshalimport importlibi = 0for frame in sys._current_frames().values(): code = frame.f_code open(&quot;dumped&quot;+str(i)+&quot;.marshal&quot;, &quot;wb&quot;).write(marshal.dumps(code)) # Loop all the threads running in the process with open(&quot;dumped&quot;+str(i)+&quot;.marshal&quot;, &quot;rb&quot;) as f: code = marshal.load(f) pyc_data = importlib._bootstrap_external._code_to_timestamp_pyc(code) # print(pyc_data) with open(&quot;file&quot;+str(i)+&quot;.pyc&quot;, &quot;wb&quot;) as f: f.write(pyc_data) i += 1print(&quot;Dump finished!&quot;) 原理就是扫描栈帧，然后将栈帧中存在的f_code (code object)以marshal文件的格式dump出来，然后转化为pyc文件。 我们将code.py的内容替换成以上内容再次注入： 查看文件夹，发现多了这几个文件： marshal文件是用于存储Python对象的序列化表示的文件。可以从marshal文件得到pyc文件。 file0.pyc 是我们 code.py 对应的pyc，我们忽略它， 用pycdc反编译一下file1.pyc： 可以看到反编译出的正是我们的test.py。 注入利用在遇到一些难以解包的exe或者解包后难以正常反编译pyc时，我们可以通过注入PVM的方式得到代码逻辑，或者对其中的一些函数进行调用，观察输出等。 关于py打包成exe打包器就是把py编译成pyc，然后连带一些模块和Python虚拟机一起塞进一个exe中。 现在主流的打包方式都是pyinstaller，但是这种打包器已经有了专门的解包器pyinstextractor， 虽然pyinstaller内置有AES的文件加密功能，但是因为pyinstaller是开源的，在运行前一定有对加密文件的解密过程，而密钥和解密流程都在打包的exe中，解包可以得到，所以只起到了一个“威慑作用”，因此，pyinstaller在6.0版本删除了–key参数：Remove the –key&#x2F;cipher bytecode encryption. 其次还有CX_freeze和py2exe两种打包器，但是这两种打包出的exe甚至都不需要解包器， CX_freeze：打包后的文件中就有pyc py2exe：直接解压exe 以上三种打包器都可十分容易地解包，PVM注入的优势并不是很明显 但是我发现另一种nuitka打包器，这个打包器是将py代码转化为c代码然后编译，所以理论上是不存在Python字节码的，也就没法解包，这时候利用PVM注入，我们就可以得到一些敏感数据和函数的信息。 参考链接Python进程注入 | Hello World blog.doctor3.net&#x2F;?p&#x3D;104","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://pinguw.github.io/categories/Reverse/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"https://pinguw.github.io/tags/Re%E5%88%86%E4%BA%AB/"},{"name":"WriteUp","slug":"WriteUp","permalink":"https://pinguw.github.io/tags/WriteUp/"}]},{"title":"IDA使用入门","slug":"Reverse/IDA","date":"2024-07-14T13:46:05.000Z","updated":"2024-07-14T14:15:37.130Z","comments":true,"path":"2024/07/14/Reverse/IDA/","permalink":"https://pinguw.github.io/2024/07/14/Reverse/IDA/","excerpt":"","text":"常用快捷键任何界面：N：重命名，可重命名函数，变量等； R：字符切换，可将数据在int型与char型之间切换； H：进制切换，可将数据在十进制与十六进制之间切换； Y：数据类型切换，可更改函数返回类型，数据类型等； X：交叉引用，可查看函数、变量甚至地址的交叉引用； Tab：在反汇编界面与汇编界面快速切换； G：前往地址处，可跳转至目标地址； F5：切换至反汇编界面，更新反汇编； Ctrl+Z：撤销操作； Ctrl+E：显示程序入口点； Shift+E：提取选中块的字节码； Shift+F1：打开本地类型定义界面 Shift+F2：打开脚本执行界面； Shift+F12：打开字符串表界面； Esc：跳转至上次跳转或退至上一界面； &#x2F;：添加注释； IDA View界面：Space（空格）：在IDA-Veiw界面（汇编界面）切换流程图与纯文本模式； U：取消定义，将光标位置的指令等取消定义，回归到数据状态； C：将光标位置的数据定义为代码，IDA将自动分析； P：编辑为函数，将从光标位置开始的代码识别为函数，IDA将自动分析； D：切换数据字宽； Structures界面：Insert：新建结构体； Delete：删除结构体； D：添加结构体成员+更改结构体成员子宽； 常用功能更改基地址： 可更改程序基地址，更改后IDA自动分析； Patch 或在IDA View界面右键空白处： 点击OK应用更改 显示字节码 其他技巧 IDA View界面的这种绿色及红色标注可以双击跳转至交叉引用处； 函数、变量、标志都可以双击跳转： IDA中的红色一般都是指分析失败&#x2F;错误的地方（往往也意味混淆的出现）： Function name栏和String栏都是可以Ctr+F打开查找的： IDA调试调试前准备主要介绍Windows物理机调试方法，Linux物理机将Windows和Linux名词替换后同理： 当使用Windows物理机调试exe文件时，直接使用Local Windows debugger即可调试： 当使用Windows物理机调试exe文件时，需要使用Linux虚拟机及Remote Linux debugger远程调试： 将IDA文件夹下&#x2F;IDA Pro&#x2F;dbgsrv&#x2F;内对应版本的调试文件复制到虚拟机内一份，并运行 回到IDA中摁F9会弹出： 在Hostname处填你的Linux虚拟机地址，其他默认内容一般无需改变， 可通过ifconfig查看Linux虚拟机IP： 然后点击OK即可开始调试。 注意使用远程调试时，输入和回显都在虚拟机命令行中。 调试技巧常用摁键： F7：步过，一行一行汇编过，遇到分支和函数会进入； F8：步跳，一行一行汇编过，遇到分支和函数会完成分支或函数内容并跳至下一行； F9：启动调试或运行至断点处； F2：设置断点； 页面分步： 其中，寄存器、栈、内存、标志位和IDA View界面都可以更改数据； 栈、内存、IDA View界面都可以通过G快捷键跳转至目标位置； 鼠标悬停至寄存器、变量或函数位置可预览其内容和地址： 在此处终止调试：","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://pinguw.github.io/categories/Reverse/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"https://pinguw.github.io/tags/Re%E5%88%86%E4%BA%AB/"}]},{"title":"敲响天堂之门","slug":"Reverse/Heaven-Gate","date":"2024-07-10T09:54:38.000Z","updated":"2024-07-16T04:13:55.074Z","comments":true,"path":"2024/07/10/Reverse/Heaven-Gate/","permalink":"https://pinguw.github.io/2024/07/10/Reverse/Heaven-Gate/","excerpt":"","text":"“天堂之门”介绍：天堂之门技术（Heaven’s Gate）是依靠Windows提供的在不同位数CPU进行跨架构的指令调用（SysWoW64），使得32位和64位的指令环境可以放在同一个程序中，即在32位WoW64进程中执行64位代码，但是目前的调试器包括IDA在内很少有能跨架构调试的，这使得调试器的调试不能正常进行，以达到反调试的目的。 一个在动态调试层面恐怕是最有难度的逆向反调试 架构之间的切换：首先我们要知道32位寄存器cs的值是0x23，64位cs寄存器的值是0x33，我们将cs的值在这两者间切换，便达到了跨架构运行程序的目的。 那么我们如何更改寄存器cs的值呢？我们知道，mov指令是无法直接改变cs寄存器的值的，需要借助call和retf来实现cs段的切换 call far和retf(ret far)是可以同时改变cs和ip的： 1234push 0x33 ;0x33作为cs的新值call $+5 ;下一条指令的地址入栈add dword [esp], 5 ;+5后即是指向retf的下一条指令retf ;跳转到下一条指令，同时pop is和pop cs 或者使用ljmp(jmp far)（仅在32位到64位时）： 1jmp far 33:地址 此外还有一种方式，在后面实现中将会提到； 这样就实现了将cs改为0x33的功能，即从32位跳转到64位。 对应的从64位跳转到32位的指令是： 1234call $+5mov dword [rsp + 4], 0x23add dword [rsp], 0xDretf 天堂之门的实现建立在对cs的更改可以让程序在32位和64之间切换的基础上。 MSVC实现（Intel格式），推荐使用： 123456789101112131415161718_asm&#123; _emit 0x6A // push 0x33 _emit 0x33 _emit 0xE8 // call $+5 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x83 // add dword [esp], 5 _emit 0x04 _emit 0x24 _emit 0x05 _emit 0xCB // retf&#125; GCC实现（AT&amp;T格式），不推荐用： 1234567891011121314151617__asm__ ( &quot;.byte 0x6A\\n\\t&quot; // push 0x33 &quot;.byte 0x33\\n\\t&quot; &quot;.byte 0xE8\\n\\t&quot; // call $+5 &quot;.byte 0x00\\n\\t&quot; &quot;.byte 0x00\\n\\t&quot; &quot;.byte 0x00\\n\\t&quot; &quot;.byte 0x00\\n\\t&quot; &quot;.byte 0x83\\n\\t&quot; &quot;.byte 0x04\\n\\t&quot; &quot;.byte 0x24\\n\\t&quot; &quot;.byte 0x05\\n\\t&quot; // add dword [esp], 5 &quot;.byte 0xCB\\n\\t&quot; // retf); 实现示例前面只介绍了对cs的更改，即cpu架构的切换，但是在我们的exe编译完成后，汇编的架构已经确定（32位），我们需要另嵌入64位的opcode到源代码中，然后让天堂之门的入口指向我们的x64_opcode才可正常执行。 下面给出一个简单的示例： 环境配置： VSMicrosoft Visual C++ v.14 - 2015； ida64+32； Release版本； x86和x64编译器结合使用； 更改VS设置： 项目-项目属性中更改以下设置：关闭随机基址：-链接器-高级-随机基址：否 保留未引用的函数&#x2F;数据：-链接器-常规-启用增量链接：否-链接器-优化-链接时间代码生成：使用链接时间代码生成&#x2F;LTCG-链接器-优化-链接时间代码生成：引用：否 关闭其他优化：-C&#x2F;C++-优化-优化：已禁用-C&#x2F;C++-代码生成-运行库：多线程（&#x2F;MT）-C&#x2F;C++-高级-调用约定：__fastcall 代码实现： 用x64编译器编写一个简单的加密： 123456789101112131415161718#include &lt;cstdio&gt;void __fastcall XOR(int&amp; a) // 统一使用__fastcall调用约定，方便传参&#123; a += 2; a ^= 0x20;&#125;int main()&#123; int a = 0x30; XOR(a); printf(&quot;%d\\n&quot;, a); return 0;&#125; 将编译出的exe放进ida64中扒出XOR函数的opcode： shift+E，提取出opcode 将代码中的XOR函数用opcode替换，main函数不作改动，用x86编译器编译运行，再次放入ida（此时运行会出错，正常现象）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;void __fastcall XOR(int&amp; a)&#123; __asm &#123; _emit 0x48 _emit 0x89 _emit 0x4c _emit 0x24 _emit 0x8 _emit 0x48 _emit 0x8b _emit 0x44 _emit 0x24 _emit 0x8 _emit 0x8b _emit 0x0 _emit 0x83 _emit 0xc0 _emit 0x2 _emit 0x48 _emit 0x8b _emit 0x4c _emit 0x24 _emit 0x8 _emit 0x89 _emit 0x1 _emit 0x48 _emit 0x8b _emit 0x44 _emit 0x24 _emit 0x8 _emit 0x8b _emit 0x0 _emit 0x83 _emit 0xf0 _emit 0x20 _emit 0x48 _emit 0x8b _emit 0x4c _emit 0x24 _emit 0x8 _emit 0x89 _emit 0x1 _emit 0xc3 &#125;&#125;int main()&#123; int a = 0x30; XOR(a); printf(&quot;%d\\n&quot;, a); return 0;&#125; 记录下这个32位程序的传参过程和opcode的起始地址，注意整个函数的起始地址跟我们的opcode的起始地址不同（也可以使用裸函数头避免这个问题）。 删去直接调用XOR的语句，使用jmp far进门，并提前push好返回地址（预留），再使用retf出门，其他部分不变。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;windows.h&gt;void __fastcall func(int&amp; a)&#123; __asm &#123; _emit 0x48 // &lt;---- address: 40108A _emit 0x89 _emit 0x4c _emit 0x24 _emit 0x8 _emit 0x48 _emit 0x8b _emit 0x44 _emit 0x24 _emit 0x8 _emit 0x8b _emit 0x0 _emit 0x83 _emit 0xc0 _emit 0x2 _emit 0x48 _emit 0x8b _emit 0x4c _emit 0x24 _emit 0x8 _emit 0x89 _emit 0x1 _emit 0x48 _emit 0x8b _emit 0x44 _emit 0x24 _emit 0x8 _emit 0x8b _emit 0x0 _emit 0x83 _emit 0xf0 _emit 0x22 _emit 0x48 _emit 0x8b _emit 0x4c _emit 0x24 _emit 0x8 _emit 0x89 _emit 0x1 _emit 0xc3 &#125;&#125;int main()&#123; int a = 0x30; __asm &#123; _emit 0x8D // lea ecx, [ebp + a] ; a _emit 0x4D _emit 0xF8 &#125; __asm &#123; _emit 0x68 // push 00000000 因为64的retn弹出8字节，而32位下的push只入栈4字节，需要手动多push 4字节的填充 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x68 // push ******** 预留好的返回地址 _emit 0xAB _emit 0xCD _emit 0xEF _emit 0xAB _emit 0xEA // ljmp 0x33, 40108A (x64_opcode初地址) _emit 0x8A _emit 0x10 _emit 0x40 _emit 0x00 _emit 0x33 _emit 0x00 &#125; __asm &#123; _emit 0xE8 // call $+5 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0xC7 // mov dword [rsp + 4], 0x23 _emit 0x44 _emit 0x24 _emit 0x04 _emit 0x23 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x83 // add dword [rsp], 0xD _emit 0x04 _emit 0x24 _emit 0x0D _emit 0xCB // retf &#125; printf(&quot;%d\\n&quot;, a); return 0;&#125; 32位编译后再次放进ida中，找到我们需要的返回地址，ida对jmp far的分析有误，不用在意 注意这里变量a在内存中的地址改变了，我们也需要更改 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;cstdio&gt;void __fastcall XOR(int&amp; a)&#123; __asm &#123; _emit 0x48 // &lt;--- address: 40108A _emit 0x89 _emit 0x4c _emit 0x24 _emit 0x8 _emit 0x48 _emit 0x8b _emit 0x44 _emit 0x24 _emit 0x8 _emit 0x8b _emit 0x0 _emit 0x83 _emit 0xc0 _emit 0x2 _emit 0x48 _emit 0x8b _emit 0x4c _emit 0x24 _emit 0x8 _emit 0x89 _emit 0x1 _emit 0x48 _emit 0x8b _emit 0x44 _emit 0x24 _emit 0x8 _emit 0x8b _emit 0x0 _emit 0x83 _emit 0xf0 _emit 0x20 _emit 0x48 _emit 0x8b _emit 0x4c _emit 0x24 _emit 0x8 _emit 0x89 _emit 0x1 _emit 0xc3 &#125;&#125;int main()&#123; int a = 0x30; __asm &#123; _emit 0x8D // lea ecx, [ebp + a] ; a _emit 0x4D _emit 0xFC // &lt;--- 注意更改传参 &#125; __asm &#123; _emit 0x68 // push 00000000 因为64的retn弹出8字节，而32位下的push只入栈4字节，需要手动多push 4字节的填充 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x68 // push 4010E2 预留好的返回地址，指向jmp far后的第一条指令 _emit 0xE2 _emit 0x10 _emit 0x40 _emit 0x00 _emit 0xEA // ljmp 0x33, 40108A (x64_opcode初地址) _emit 0x8A _emit 0x10 _emit 0x40 _emit 0x00 _emit 0x33 _emit 0x00 &#125; __asm &#123; _emit 0xE8 // call $+5 &lt;--- address: 4010E2 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0xC7 // mov dword [rsp + 4], 0x23 _emit 0x44 _emit 0x24 _emit 0x04 _emit 0x23 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x83 // add dword [rsp], 0xD _emit 0x04 _emit 0x24 _emit 0x0D _emit 0xCB // retf &#125; printf(&quot;%d\\n&quot;, a); return 0;&#125; 运行验证结果： 其他实现上面是使用了jmp far进门方式，下面介绍另外两种进门方式： 利用call far进门123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;cstdio&gt;void __fastcall XOR(int&amp; a)&#123; __asm &#123; _emit 0xC6 // &lt;--- address: 40108A _emit 0x44 // call far 会将cs也入栈，我们直接改掉 _emit 0x24 // mov byte [rsp + 4], 0 _emit 0x04 _emit 0x00 _emit 0x48 _emit 0x89 _emit 0x4c _emit 0x24 _emit 0x8 _emit 0x48 _emit 0x8b _emit 0x44 _emit 0x24 _emit 0x8 _emit 0x8b _emit 0x0 _emit 0x83 _emit 0xc0 _emit 0x2 _emit 0x48 _emit 0x8b _emit 0x4c _emit 0x24 _emit 0x8 _emit 0x89 _emit 0x1 _emit 0x48 _emit 0x8b _emit 0x44 _emit 0x24 _emit 0x8 _emit 0x8b _emit 0x0 _emit 0x83 _emit 0xf0 _emit 0x20 _emit 0x48 _emit 0x8b _emit 0x4c _emit 0x24 _emit 0x8 _emit 0x89 _emit 0x1 _emit 0xc3 &#125;&#125;unsigned char target[8] = &#123;0x8A, 0x10, 0x40, 0x00, 0x33, 0x00, 0x00, 0x00&#125;; // 这里存好opcode的地址int main()&#123; int a = 0x30; __asm &#123; lea ecx, [ebp - 4] &#125; __asm &#123; call fword ptr target // call fword ptr target(4468C0) &lt;=&gt; call far 33:40108A &#125; __asm &#123; _emit 0xE8 // call $+5 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0xC7 // mov dword [rsp + 4], 0x23 _emit 0x44 _emit 0x24 _emit 0x04 _emit 0x23 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x83 // add dword [rsp], 0xD _emit 0x04 _emit 0x24 _emit 0x0D _emit 0xCB // retf &#125; printf(&quot;%d\\n&quot;, a); return 0;&#125; 这种方法需要注意的是：call far会将cs一起入栈，一共入栈8字节， 所以我们直接改掉就好，也不需要再push 0了 利用retf进门123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;void __fastcall XOR(int&amp; a)&#123; __asm &#123; _emit 0x48 // &lt;--- address: 40108A _emit 0x89 _emit 0x4c _emit 0x24 _emit 0x8 _emit 0x48 _emit 0x8b _emit 0x44 _emit 0x24 _emit 0x8 _emit 0x8b _emit 0x0 _emit 0x83 _emit 0xc0 _emit 0x2 _emit 0x48 _emit 0x8b _emit 0x4c _emit 0x24 _emit 0x8 _emit 0x89 _emit 0x1 _emit 0x48 _emit 0x8b _emit 0x44 _emit 0x24 _emit 0x8 _emit 0x8b _emit 0x0 _emit 0x83 _emit 0xf0 _emit 0x20 _emit 0x48 _emit 0x8b _emit 0x4c _emit 0x24 _emit 0x8 _emit 0x89 _emit 0x1 _emit 0xc3 &#125;&#125;int main()&#123; int a = 0x30; __asm &#123; lea ecx, [ebp - 4] &#125; __asm &#123; push 0x33 call $ + 5 add dword ptr [esp], 5 retf &#125; __asm &#123; _emit 0xE8 // call的相对跳转 call 40108A _emit 0xA8 // 目标地址与call的后一条指令地址的差 _emit 0xFF _emit 0xFF _emit 0xFF &#125; __asm &#123; _emit 0xE8 // call $+5 &lt;--- address: 4010E2 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0xC7 // mov dword [rsp + 4], 0x23 _emit 0x44 _emit 0x24 _emit 0x04 _emit 0x23 _emit 0x00 _emit 0x00 _emit 0x00 _emit 0x83 // add dword [rsp], 0xD _emit 0x04 _emit 0x24 _emit 0x0D _emit 0xCB // retf &#125; printf(&quot;%d\\n&quot;, a); return 0;&#125; 这种方式最为简单，只需要预留好偏移量即可，但也最容易被发现。 以上三种跳转方式结合使用可以进一步增加天堂之门的逆向难度 出题技巧 单独起一个天堂之门跳转后检测调试，如果检测到调试更改掉 key（用反调试隐藏反调试）； 利用花指令、SEH异常处理、SMC等混淆手段隐藏掉天堂之门入口处的跳转指令； 多种跳转方式结合使用； 实战西湖论剑2023 Dual personality 这里对题目的分析更偏向于各种跨架构的跳转，具体的加密代码分析及逆向过程仅作简略说明 32位无壳，拖进ida， 不出意外一片红，在输入后下断点： 单步跳，4013E3处call完sub_401120这个函数后发现更改了从4013E8开始的后面一部分的内存，undefine + make code让ida重新识别后发现jmp far指令，这就是门的入口了： 那么sub_401120就是利用了SMC开门的函数，标记一下， 看字节码找到jmp到的位置：4011D0也就是上面push进栈的地址， ida反汇编失败，因为jmp far已经更改了cs，所以4011D0这里都是x64的opcode了，ida32显然不能正确识别， 需要我们更改exe的魔术子，改用ida64分析， PE文件里这个位置的010B是32位文件标志字，020B是64位文件标志字，我们把01改成02，放进ida64： 在这里更改基地址为400000，然后go 0x4011D0，C+P识别为函数： 看到这里检测调试，然后如果不在调试才给dword_407058赋正确的初始值，然后jmp到407000的内存内容的位置， 回到ida32中查看407000内存的内容： 那么这个4011D0函数运行完后会jmp到5E0000的位置，跳过去看看， 如果eax的值不为零就跳转到4013EF，那么下面就go 4013EF， 这里把dword_407058减去了一个值，然后继续jmp，继续跟， 401417这里是第一个加密函数，是对dword_407058做的操作，我们把dword_407058更名成key： 上面的操作执行完后会跳转到这个位置： 这里看到了我们熟悉的call far，跳转的目的地就是byte_40700C的内容：401200 可见这里也同时改了cs，是第二个门，我们在ida64中go 401200看第二段加密： 声明函数后可以看到简陋的反汇编，这里也判断了调试的标志位，那么正确的加密应该是else里的内容， 这个函数进行完后就直接retf了，我们回到上一张图的位置继续看： 又用到了我们第一次进门用的entry_gate函数，push的地址为401290，那么第三个门就是401290，到ida64中go 401290： 进行了一些位运算，注意这里的操作是错位的， 然后回到汇编层面： 把0x4014C5赋给dword_407000，那么5E0000的地方就是jmp到4014C5， 注意此时dword_407000里带着0x23，那么下次jmp就会把cs改回0x23也就是回到32位， 最后就是check flag了。 参考链接 逆向基础笔记九 C语言内联汇编和调用约定 天堂之门技术 | Taardis’s blog [原创]天堂之门 (Heaven’s Gate) C语言实现 [原创]天堂之门-调试器的末路","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://pinguw.github.io/categories/Reverse/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"https://pinguw.github.io/tags/Re%E5%88%86%E4%BA%AB/"}]},{"title":"HASHCTF2024-Reverse题解","slug":"比赛WP/HASHCTF2024","date":"2024-06-05T07:47:44.000Z","updated":"2024-06-05T08:24:23.463Z","comments":true,"path":"2024/06/05/比赛WP/HASHCTF2024/","permalink":"https://pinguw.github.io/2024/06/05/%E6%AF%94%E8%B5%9BWP/HASHCTF2024/","excerpt":"","text":"校赛也是ak re了，总排名第二，一等奖+Reverse单项最佳。 一人干活，七人围观！主要逻辑在这里： 是个多线程代码，线程影响v3的取值和异或的对象，直接上代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;void dec(unsigned char* enc)&#123; char key[] = &quot;HASH2024&quot;; for(int round = 1; round &lt;= 8; round++) &#123; for(int count = 8; count &gt;= 1;) &#123; int v4 = 8 - count; int v3 = ((4 * round) | round) ^ key[8 - count--]; for(int i = 0; i &lt; 8; i++) enc[v4 * 8 + i] ^= v3; &#125; &#125; for(int i = 0; i &lt; 64; i++) printf(&quot;%c&quot;, enc[i]);&#125;int main()&#123; unsigned char enc_flag[] = &#123; 0x60, 0x69, 0x7B, 0x60, 0x6B, 0x7C, 0x6E, 0x53, 0x66, 0x18, 0x5F, 0x77, 0x7D, 0x77, 0x40, 0x1C, 0x5E, 0x1B, 0x77, 0x1B, 0x50, 0x58, 0x44, 0x18, 0x5A, 0x1B, 0x4C, 0x77, 0x1F, 0x40, 0x1B, 0x77, 0x4B, 0x18, 0x46, 0x4B, 0x7D, 0x5A, 0x02, 0x1A, 0x4D, 0x46, 0x4B, 0x51, 0x77, 0x18, 0x4E, 0x77, 0x1F, 0x40, 0x1B, 0x77, 0x6B, 0x77, 0x44, 0x1C, 0x46, 0x4F, 0x5D, 0x1C, 0x4F, 0x1B, 0x09, 0x55 &#125;; dec((unsigned char*)enc_flag); return 0;&#125; HASHCTF{N1w_U_h4v3_3xpl0r3d_7h3_c0ncUr*2ency_0f_7h3_c_l4ngu4g3!} 解完之后想起来，既然加密是异或，大概率调试的时候把密文输入，那么最后判断时的结果就是flag，出题人的回答印证了我的猜想，不过是一血，没什么影响。 Teaflower十分钟秒杀题。 有壳去壳，有花去花， 壳是简单的upx一键去，花是简单的跳转全nop， TEA的delta魔改了一下，直接写解密代码： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;void decrypt (uint32_t* v, uint32_t* k)&#123; uint32_t v0 = v[0], v1 = v[1], sum = 0xBABEEAEA * 32; uint32_t delta = 0xBABEEAEA; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for(int i = 0; i &lt; 32; i++) &#123; v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); sum -= delta; &#125; v[0] = v0; v[1] = v1;&#125;int main()&#123; unsigned char enc_flag[] = &#123; 0x32, 0x31, 0x75, 0x08, 0x27, 0x72, 0xD5, 0x62, 0xE9, 0x2C, 0xA5, 0xAE, 0x98, 0x03, 0x5E, 0x4F, 0xEB, 0x25, 0xC3, 0xAD, 0xBB, 0x25, 0x49, 0x7D, 0x88, 0xAE, 0x9C, 0x73, 0x21, 0x37, 0xAA, 0x4D, 0x77, 0xA1, 0xBA, 0x08, 0xE9, 0xBB, 0x28, 0x29, &#125;; unsigned char key[32] = &quot;HASH2024HASH2024&quot;; for(int i = 0; i &lt; 40; i += 8) decrypt((unsigned int*)&amp;enc_flag[i], (unsigned int*)key); for(int i = 0; i &lt; 40; i++) printf(&quot;%c&quot;, enc_flag[i]); return 0;&#125; HASHCTF{W0o0w_U_cAn_r3@11y_r3v3r53_14!!} babycode我忘了是怎么知道的以太坊虚拟机（大概是拷打GPT的时候它招的供词），找一个能把字节码还原成汇编的网站https://ethervm.io/decompile： 发现有两处位置一直在push数据，将两块数据扒下来，后面还有XOR指令加上出题人提示，将两块数据异或，得到flag： 123456data1 = [0x1b, 0x24, 0x30, 0x3d, 0x31, 0x31, 0x0d, 0x3e, 0x0a, 0x0a, 0x4f, 0x67, 0x3a, 0x09, 0x51, 0x30, 0x08, 0x13, 0x32, 0x2b, 0x0d, 0x26, 0x3c, 0x24, 0x30, 0x78, 0x27, 0x67, 0x19, 0x2d, 0x57, 0x46, 0x57, 0x46, 0x2c, 0x07, 0x7e, 0x10, 0x4e]data2 = [0x53, 0x65, 0x63, 0x75, 0x72, 0x65, 0x4b, 0x45, 0x59, 0x3a, 0x20, 0x57, 0x65, 0x6c, 0x63, 0x6f, 0x6d, 0x65, 0x5f, 0x74, 0x6f, 0x5f, 0x48, 0x41, 0x53, 0x48, 0x43, 0x54, 0x46, 0x5f, 0x32, 0x30, 0x32, 0x34, 0x5f, 0x34, 0x5f, 0x31, 0x33]for i in range(len(data1)): print(chr(data1[i] ^ data2[i]), end = &#x27;&#x27;) HASHCTF{S0o0_e2_evm_bytec0d3_revers3!!} 高速龙车驾驶员直接运行报错需要支持库，走出题人不建议的路线loongarch交叉编译工具链（因为建议的路我不会走）， 安装后里面有loongarch64-objdump，用他dump出文件的汇编代码和数据段： 对照出题人给的文档，分析汇编： 123456789101112131415161718192021... sp -= 32 sp[8] = s1 sp[16] = s0 sp[24] = ra a1 += 7612 t0 += 171 xr1 = a1 xr0 = a1[32] t1 += 160 xr2 = t0 for (int i = 0; i &lt; 4; i++) xr0 ^= xr2 xr0 = a1[32] xr3 = t1 a0 = 8 a0 = 152 for (int i = 0; i &lt; 4; i++) xr1 ^= xr3 a1[0] = xr1... 关键部分如上：异或加密。 从扒出的数据段中做尝试，最终试出将data段与rodata段异或得到flag。 123456789101112131415161718data1 = [0x5e, 0x7f, 0xec, 0x4f, 0x32, 0x30, 0xbb, 0x6c, 0x6b, 0xd7, 0x69, 0x70, 0xd7, 0xba, 0x53, 0x37]data2 = [0x80, 0Xef, 0X4c, 0X69, 0X92, 0X9c, 0X38, 0X91, 0X92, 0Xb6, 0X38, 0Xde, 0X28, 0X0e, 0Xcd, 0X63]data3 = [0xcd, 0xa2, 0xc1, 0x23, 0xbd, 0x30, 0xf5, 0x3a, 0x26, 0x33, 0xda, 0xfc, 0xaf, 0xad, 0xfa, 0x2d]data4 = [0x8d, 0x20, 0x54, 0x2b, 0x37, 0x91, 0x5e, 0xad, 0xd0, 0xf8, 0xb2, 0xe7, 0xea, 0xfe, 0xc1, 0xc7]key1 = [0x16, 0x3e, 0xbf, 0x07, 0x71, 0x64, 0xfd, 0x17, 0x32, 0xb8, 0x1c, 0x2f, 0x88, 0xd1, 0x3d, 0x58]key2 = [0xf7, 0xb0, 0x13, 0x36, 0xde, 0xf3, 0x08, 0xfe, 0xfd, 0x86, 0x57, 0xb1, 0x18, 0x60, 0xaa, 0x22]key3 = [0xbf, 0xc1, 0xa9, 0x7c, 0xe2, 0x6f, 0xb9, 0x7b, 0x75, 0x6b, 0x85, 0xa3, 0xfc, 0xc2, 0xca, 0x42]key4 = [0xe2, 0x10, 0x3b, 0x44, 0x07, 0xce, 0x01, 0xf2, 0x87, 0x9d, 0xde, 0x8b, 0xcb, 0xdf, 0xbc, 0xc7]for i in range(len(data1)): print(chr(data1[i] ^ key1[i]), end = &#x27;&#x27;)for i in range(len(data1)): print(chr(data2[i] ^ key2[i]), end = &#x27;&#x27;)for i in range(len(data1)): print(chr(data3[i] ^ key3[i]), end = &#x27;&#x27;)for i in range(len(data1)): print(chr(data4[i] ^ key4[i]), end = &#x27;&#x27;) HASHCTF{You__ know__ _ Lo0oo0oo0ngArch___ LASX_ _So0oo0oo0___Well!!} xorust简单恢复一下符号表： 在func函数中找到关键部分： 扒取数据： 发现这些数据比input少一位，试着在最前面加 H或者在最后面加 &#125;， 写出解密代码： 1234567891011data = [0x09, 0x12, 0x1B, 0x0B, 0x17, 0x12, 0x3D, 0x2C, 0x32, 0x54, 0x52, 0x53, 0x5D, 0x08, 0x3A, 0x10, 0x3A, 0x07, 0x2D, 0x0D, 0x27, 0x06, 0x27, 0x0B, 0x12, 0x0D, 0x33, 0x07, 0x47, 0x41, 0x2D, 0x6B, 0x5B, 0x30, 0x15, 0x7A, 0x59, 0x07, 0x31, 0x2B, 0x3C, 0x2D, 0x26, 0x2C, 0x22, 0x3D, 0x0D]data[0] ^= ord(&#x27;H&#x27;)print(&#x27;H&#x27;, end = &#x27;&#x27;)for i in range(1, len(data)): data[i] ^= data[i - 1]for i in data: print(chr(i), end = &#x27;&#x27;) HASHCTF{We1c0me_Our_RusT_M@st3r_4o_J0in_tHeCoMp}","categories":[{"name":"比赛WP","slug":"比赛WP","permalink":"https://pinguw.github.io/categories/%E6%AF%94%E8%B5%9BWP/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://pinguw.github.io/tags/WriteUp/"}]},{"title":"RCTF2024部分题解","slug":"比赛WP/RCTF2024","date":"2024-05-29T12:52:43.000Z","updated":"2024-06-05T08:07:25.456Z","comments":true,"path":"2024/05/29/比赛WP/RCTF2024/","permalink":"https://pinguw.github.io/2024/05/29/%E6%AF%94%E8%B5%9BWP/RCTF2024/","excerpt":"","text":"四道re（那个misc就是纯逆向） Reverse2048审计源码，看出每轮将获得分数为输入的sorce，上限为当前得分，初次上限为1w，那么每次成功分数翻倍的情况下用不了几次即可到达100w分： RCTF{you_are_2048_master} bloker_vm在每种case中下断点，可得到加密逻辑， 但是没看出反调试的影响在哪里。 解密代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;int rc4(unsigned char* input, int input_len, char* key, int key_len)&#123; int result; // eax char v5; // [esp+D3h] [ebp-155h] char v6; // [esp+D3h] [ebp-155h] int v7; // [esp+F4h] [ebp-134h] int i; // [esp+100h] [ebp-128h] int j; // [esp+100h] [ebp-128h] int k; // [esp+100h] [ebp-128h] unsigned __int8 v11; // [esp+10Fh] [ebp-119h] unsigned __int8 v12; // [esp+11Bh] [ebp-10Dh] char v13[260]; // [esp+124h] [ebp-104h] for(i = 0; i &lt; 256; ++i) v13[i] = i; v7 = 0; for(j = 0; j &lt; 256; ++j) &#123; v7 = ((unsigned __int8)key[j % key_len] + v7 + (unsigned __int8)v13[j]) % 256; v5 = v13[j]; v13[j] = v13[v7]; v13[v7] = v5; &#125; v12 = 0; v11 = 0; for(k = 0; ; ++k) &#123; result = k; if(k &gt;= input_len) break; v11 += v13[++v12]; v6 = v13[v12]; v13[v12] = v13[v11]; v13[v11] = v6; input[k] ^= v13[((unsigned __int8)v13[v11] + (unsigned __int8)v13[v12]) % 256]; &#125; return result;&#125;int main()&#123; unsigned char enc_flag[] = &#123; 0x80, 0x05, 0xE3, 0x2F, 0x18, 0x2F, 0xC5, 0x8C, 0x25, 0x70, 0xBC, 0x05, 0x1C, 0x4F, 0xF2, 0x02, 0xE5, 0x3E, 0x02, 0x2F, 0xE5, 0x11, 0xA3, 0xC0 &#125;; char key[] = &quot;thisisyoursecretkey&quot;; rc4(enc_flag, 24, key, 18); for(int i = 0; i &lt; 24; i++) &#123; enc_flag[i] = (enc_flag[i] &lt;&lt; 2) &amp; 63 | (enc_flag[i] &gt;&gt; 6); enc_flag[i] ^= 0x7D; printf(&quot;%c&quot;, enc_flag[i]); &#125; return 0;&#125; RCTF{a_baby_debug_bloker} PPTT看到mian函数中先将输入写成二叉树层序存储，然后先序和中序遍历，并对中序的结果进行交换混淆， v23，v24，v25存储的即为中序遍历的结果，z3解方程可得 z3解方程+还原： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from Crypto.Util.number import *from z3 import *v17 = BitVec(&#x27;v17&#x27;, 64)v18 = BitVec(&#x27;v18&#x27;, 64)v19 = BitVec(&#x27;v19&#x27;, 64)v20 = BitVec(&#x27;v20&#x27;, 64)v23 = BitVec(&#x27;v23&#x27;, 64)v24 = BitVec(&#x27;v24&#x27;, 64)v25 = BitVec(&#x27;v25&#x27;, 64)s = Solver()s.add(v20 == v24 &amp; v23)s.add(v19 == (v24 &amp; v23 | v25 &amp; v23) + 65670)s.add(v18 == (v25 &amp; v23 ^ v25 &amp; v24) - 1131796)s.add(v17 == v24 &amp; v23 ^ v25 &amp; v23)# s.add((v24 &amp; v23 &amp; (~(v24 | v23) | v25 &amp; v23 | v25 &amp; v24 &amp; ~v18) | v25 &amp; v24 &amp; v18) != 0x67437616)s.add((v23 ^ (v20 &amp; ~v18 | v20 &amp; ~v19 | v17 &amp; v19 | v25 &amp; v23 &amp; ~v18)) == 0x400010000622000)s.add((v18 ^ (v19 - v20)) == 0x2100A0203EFBB8B)s.add((v17 ^ v19 ^ v20) == 0x4083102108E)s.add((v19 ^ v17) - v18 == 0x1551566F3C6485ED)s.add((v18 ^ v19 ^ v25 &amp; v24) == 0x40836ECAB9A)s.add((v17 ^ v20) - v18 == 0x3E51566F3C718563)s.add(v23 - v24 == 0x1AEFF6FDFC121BF1)s.add((v25 + v24 + v23) % 10 == 8)while s.check() == sat: model = s.model() tmp = long_to_bytes(model[v25].as_long()) s.add(v25 != model[v25]) if len(str(tmp)) != 11 or tmp.find(b&#x27;C&#x27;) == -1 or tmp.find(b&#x27;F&#x27;) == -1 or tmp.find(b&#x27;&#125;&#x27;) == -1: continue mid1 = long_to_bytes(model[v23].as_long()) mid2 = long_to_bytes(model[v24].as_long()) mid3 = long_to_bytes(model[v25].as_long()) # print(mid1[::-1]) # print(mid2[::-1]) # print(mid3[::-1]) str1 = &#x27;0123456789abcdefghijklmn&#x27; str2 = &#x27;gefckamb52hl48i0n1j396d7&#x27; mid = mid1[::-1]+mid2[::-1]+mid3[::-1] flag = &#x27;&#x27; for i in range(24): flag += chr(mid[str2.find(str1[i])]) print(flag) 一个一个验证所有解 RCTF{sjknwemqspsdaqtyua} Miscs1ayth3sp1re这应该是个re题。 把文件拖进jadx查找判断胜利的条件： 直接看加密逻辑，简单异或： 写解密代码： 1234567891011121314151617arr1 = [164, 158, 95, 107, 4, 215, 108, 115, 5, 8, 25, 57, 41, 236, 231, 17, 85]arr2 = [246, 221, 11, 45, 127, 148, 45, 36, 70, 73, 78, 8, 98, 141, 140, 112, 40]enc1 = [0] * len(arr1)for i in range(len(arr1)): enc1[i] = arr1[i] ^ arr2[i] print(chr(enc1[i]), end = &#x27;&#x27;)print()arr3 = [100, 174, 197, 56]arr4 = [2, 0xC2, 164, 95]enc2 = [0] * len(arr3)for i in range(len(arr3)): enc2[i] = arr3[i] ^ arr4[i] print(chr(enc2[i]), end = &#x27;&#x27;) RCTF{CAWCAW1Kaka}","categories":[{"name":"比赛WP","slug":"比赛WP","permalink":"https://pinguw.github.io/categories/%E6%AF%94%E8%B5%9BWP/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://pinguw.github.io/tags/WriteUp/"}]},{"title":"CISCN2024-Reverse部分题解","slug":"比赛WP/CISCN2024","date":"2024-05-22T07:21:02.000Z","updated":"2024-06-05T08:08:20.086Z","comments":true,"path":"2024/05/22/比赛WP/CISCN2024/","permalink":"https://pinguw.github.io/2024/05/22/%E6%AF%94%E8%B5%9BWP/CISCN2024/","excerpt":"","text":"很菜，初赛只出了三道题。 asm_re拿到手是IDA的view界面， main函数逻辑交给GPT，是简单的加减乘除异或， data段手动dump出+解密： 1234567891011121314151617181920212223242526272829303132333435363738394041data = [ 0xD7, 0x1F, 0x00, 0x00, 0xB7, 0x21, 0x00, 0x00, 0x47, 0x1E, 0x00, 0x00, 0x27, 0x20, 0x00, 0x00, 0xE7, 0x26, 0x00, 0x00, 0xD7, 0x10, 0x00, 0x00, 0x27, 0x11, 0x00, 0x00, 0x07, 0x20, 0x00, 0x00, 0xC7, 0x11, 0x00, 0x00, 0x47, 0x1E, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0xF7, 0x11, 0x00, 0x00, 0x07, 0x20, 0x00, 0x00, 0x37, 0x10, 0x00, 0x00, 0x07, 0x11, 0x00, 0x00, 0x17, 0x1F, 0x00, 0x00, 0xD7, 0x10, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0x67, 0x1F, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0xC7, 0x11, 0x00, 0x00, 0xC7, 0x11, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0xD7, 0x1F, 0x00, 0x00, 0x17, 0x1F, 0x00, 0x00, 0x07, 0x11, 0x00, 0x00, 0x47, 0x0F, 0x00, 0x00, 0x27, 0x11, 0x00, 0x00, 0x37, 0x10, 0x00, 0x00, 0x47, 0x1E, 0x00, 0x00, 0x37, 0x10, 0x00, 0x00, 0xD7, 0x1F, 0x00, 0x00, 0x07, 0x11, 0x00, 0x00, 0xD7, 0x1F, 0x00, 0x00, 0x07, 0x11, 0x00, 0x00, 0x87, 0x27, 0x00, 0x00]print(len(data) // 4)tmp = &#x27;&#x27;for i in range(0, len(data), 4): if(len(hex(data[i])[2:]) == 1): tmp = &#x27;0&#x27; + hex(data[i])[2:] else: tmp = hex(data[i])[2:] print(&#x27;0x&#x27;, hex(data[i + 1])[2:], tmp, sep = &#x27;&#x27;, end = &#x27;, &#x27;)print()flag = [ 0x1fd7, 0x21b7, 0x1e47, 0x2027, 0x26e7, 0x10d7, 0x1127, 0x2007, 0x11c7, 0x1e47, 0x1017, 0x1017, 0x11f7, 0x2007, 0x1037, 0x1107, 0x1f17, 0x10d7, 0x1017, 0x1017, 0x1f67, 0x1017, 0x11c7, 0x11c7, 0x1017, 0x1fd7, 0x1f17, 0x1107, 0xf47, 0x1127, 0x1037, 0x1e47, 0x1037, 0x1fd7, 0x1107, 0x1fd7, 0x1107, 0x2787]for i in range(38): print(chr((((flag[i] - 30) ^ 70) - 20) // 80), end = &#x27;&#x27;) flag{67e9a228e45b622c2992fb5174a4f5f5} androidso_re从jadx中看到是CBC的DES， 进so看getkey和getiv的加密方式， key是简单的RC4加异或，iv是凯撒密码。 key: iv: 对key和iv的解密： 12345678910111213141516RC4_key = [0x42, 0xb1, 0x66, 0xdc, 0x03, 0x6d, 0x45, 0x1b, 0xc2, 0x3b, 0x58, 0xba]xor_key = [0x03, 0x89, 0x33, 0xB8, 0x54, 0x0C, 0x20, 0x6A]for i in range(len(xor_key)): print(chr(RC4_key[i + k] ^ xor_key[i]), end = &#x27;&#x27;)print()enc_iv = &quot;F2IjBOh1mRW=&quot;for i in enc_iv: if(i.islower()): print(chr(ord(&#x27;a&#x27;) + (ord(i) - 81) % 26), end = &#x27;&#x27;) elif(i.isupper()): print(chr(ord(&#x27;A&#x27;) + (ord(i) - 49) % 26), end = &#x27;&#x27;) else: print(i, end = &#x27;&#x27;) DES的解密： flag{188cba3a5c0fbb2250b5a2e590c391ce} gdb_debug 动调出两处xor_key和一个sbox，然后写代码解密： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# XORenc_flag = [0xBF, 0xD7, 0x2E, 0xDA, 0xEE, 0xA8, 0x1A, 0x10, 0x83, 0x73, 0xAC, 0xF1, 0x06, 0xBE, 0xAD, 0x88, 0x04, 0xD7, 0x12, 0xFE, 0xB5, 0xE2, 0x61, 0xB7, 0x3D, 0x07, 0x4A, 0xE8, 0x96, 0xA2, 0x9D, 0x4D, 0xBC, 0x81, 0x8C, 0xE9, 0x88, 0x78, 0x00, 0x00,]key = &quot;congratulationstoyoucongratulationstoy&quot;for i in range(38): enc_flag[i] ^= ord(key[i])#==============================================================================# XORc = [0x03, 0x12, 0x0C, 0x4C, 0xC6, 0x26, 0x8C, 0x63, 0xB6, 0x87, 0xB0, 0x6F, 0x1A, 0xCB, 0x9B, 0xFD, 0xBC, 0x52, 0x79, 0x93, 0x19, 0x6A, 0xDA, 0x4E,0x7B, 0xF9, 0xC4, 0xBB, 0xF1, 0x7E, 0x9D, 0x1E,0x44, 0xD6, 0xC5, 0x50, 0xBF, 0xEE, 0x00, 0x00,]d = [0xDD, 0xB8, 0x4E, 0xB0, 0xCF, 0xCE, 0x3E, 0x65,0xBB, 0x14, 0xD1, 0x9B, 0x3E, 0x82, 0x8E, 0xFC,0x6B, 0xF9, 0x7D, 0x8B, 0xD6, 0x83, 0x0F, 0xD8,0x48, 0x33, 0x3D, 0x91, 0xAF, 0x94, 0xB0, 0x22,0xD0, 0xB9, 0xFD, 0xCD, 0xE7, 0x04, 0x00, 0x00,]# for i in c:# for j in range(15, -1, -2):# print(&#x27;0x&#x27;+i[j - 1]+i[j]+&#x27;, &#x27;, end = &#x27;&#x27;)# print()# print()# for i in d:# for j in range(15, -1, -2):# print(&#x27;0x&#x27;+i[j - 1]+i[j]+&#x27;, &#x27;, end = &#x27;&#x27;)# print()xor_key2 = [0] * 38for i in range(38): xor_key2[i] = c[i] ^ d[i]for i in range(38): enc_flag[i] ^= xor_key2[i]#==============================================================================# ENCs_box = [0x12, 0x0E, 0x1B, 0x1E, 0x11, 0x05, 0x07, 0x01, 0x10, 0x22, 0x06, 0x17, 0x16, 0x08, 0x19, 0x13, 0x04, 0x0F, 0x02, 0x0D, 0x25, 0x0C, 0x03, 0x15,0x1C, 0x14, 0x0B, 0x1A, 0x18, 0x09, 0x1D, 0x23,0x1F, 0x20, 0x24, 0x0A, 0x00, 0x21, 0x00, 0x00,]# for i in s_box:# for j in range(15, -1, -2):# print(&#x27;0x&#x27;+i[j - 1]+i[j]+&#x27;, &#x27;, end = &#x27;&#x27;)# print()flag = [0] *38for i in range(38): flag[s_box[i]] = enc_flag[i]#==============================================================================# XORa = r&quot;flag&#123;0123456789abcdef0123456789abcdef&#125;&quot;b = [0xBF, 0x63, 0x79, 0xDA, 0xBC, 0x26, 0xB0, 0x8C, 0xCB, 0x7E, 0x50, 0xC4, 0x6A, 0x93, 0x12, 0x52, 0xB6, 0xC6, 0x03, 0xFD, 0xF9, 0x4E, 0x1A, 0x6F,0xF1, 0x9B, 0xBB, 0x0C, 0x7B, 0x9D, 0x4C, 0x44,0xD6, 0xEE, 0x87, 0x1E, 0xC5, 0x19, 0x00, 0x00,]# for i in b:# for j in range(15, -1, -2):# print(&#x27;0x&#x27;+i[j - 1]+i[j]+&#x27;, &#x27;, end = &#x27;&#x27;)# print()for i in range(38): xor_key1[i] = ord(a[i]) ^ b[i]for i in range(38): flag[i] ^= xor_key1[i]xor_key1 = [0] * 38#==============================================================================for i in range(38): print(chr(flag[i]), end = &#x27;&#x27;) flag{78bace5989660ee38f1fd980a4b4fbcd}","categories":[{"name":"比赛WP","slug":"比赛WP","permalink":"https://pinguw.github.io/categories/%E6%AF%94%E8%B5%9BWP/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://pinguw.github.io/tags/WriteUp/"}]},{"title":"H&NCTF2024-Reverse部分题解","slug":"比赛WP/H&NCTF2024","date":"2024-05-13T15:48:29.000Z","updated":"2024-06-05T08:08:38.011Z","comments":true,"path":"2024/05/13/比赛WP/H&NCTF2024/","permalink":"https://pinguw.github.io/2024/05/13/%E6%AF%94%E8%B5%9BWP/H&NCTF2024/","excerpt":"","text":"其他的re就没时间做了（我承认是我菜） Baby_OBVBS打开之后看见是VBS混淆，将混淆部分打印出来（base64内容部分略去）： 123456789101112131415161718192021222324252627eAqi = &quot;59fc6b263c3d0fcbc331ade699e62d3473bbf85522d588e3423e6c751ca091528a3c0186e460483917192c14&quot;ANtg = &quot;baacc7ffa8232d28f814bb14c428798b&quot;Function Base64Decode(base64EncodedString) Dim xml, elem Set xml = CreateObject(&quot;MSXML2.DOMDocument&quot;) Set elem = xml.createElement(&quot;tmp&quot;) elem.dataType = &quot;bin.base64&quot; elem.text = base64EncodedString Dim stream Set stream = CreateObject(&quot;ADODB.Stream&quot;) stream.Type = 1 &#x27;Binary stream.Open stream.Write elem.nodeTypedValue stream.Position = 0 stream.Type = 2 &#x27;Text stream.Charset = &quot;utf-8&quot; Base64Decode = stream.ReadText stream.CloseEnd Functionnbbt=&quot;RnVuY3Rpb24gSW5pdGlhbGl6ZShzdHJQd2QpDQogICAgRGltIGJveCgyNTYpDQogICAgRGltIHRlbXBTd2FwDQogICAgRGltIGENCiAg&quot;execute base64Decode(nbbt)NFqt=&quot;RnVuY3Rpb24gTXlmdW5jKHNZCBGdW5jdGlvbg==&quot;execute base64Decode(NFqt)NsFw=&quot;RnVuY3Rpb24gRWNTYpDQogICAgICAgIGVuY3J5cHRlZERhdGEgPSBlbmNyeXB0ZWREYXRhICYgTENhc2UoUmlnaHQoIjAiICYgSGV4KHkpLCAyKSkNCiAgICBOZXh0DQogICAgRW5DcnlwdCA9IGVuY3J5cHRlZERhdGENCkVuZCBGdW5jdGlvbg==&quot;execute base64Decode(NsFw)hYLu=&quot;bXNnYm94ICJEbyB5b3Uga28gImJ5ZSEi&quot;execute base64Decode(hYLu) base64解密后得到加密代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798Function RC4_init(strPwd) Dim box(256) Dim tempSwap Dim a Dim b For i = 0 To 255 box(i) = i Next a = 0 b = 0 For i = 0 To 255 a = (a + box(i) + Asc(Mid(strPwd, (i Mod Len(strPwd)) + 1, 1))) Mod 256 tempSwap = box(i) box(i) = box(a) box(a) = tempSwap Next RC4_init = boxEnd FunctionFunction MD5(strToHash) Dim tmpFile, strCommand, objFSO, objWshShell, out Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;) Set objWshShell = CreateObject(&quot;WScript.Shell&quot;) tmpFile = objFSO.GetSpecialFolder(2).Path &amp; &quot;\\&quot; &amp; objFSO.GetTempName objFSO.CreateTextFile(tmpFile).Write(strToHash) strCommand = &quot;certutil -hashfile &quot; &amp; tmpFile &amp; &quot; MD5&quot; out = objWshShell.Exec(strCommand).StdOut.ReadAll objFSO.DeleteFile tmpFile MD5 = Replace(Split(Trim(out), vbCrLf)(1), &quot; &quot;, &quot;&quot;)End FunctionFunction RC4(box, strData) Dim tempSwap Dim a Dim b Dim x Dim y Dim encryptedData encryptedData = &quot;&quot; For x = 1 To Len(strData) a = (a + 1) Mod 256 b = (b + box(a)) Mod 256 tempSwap = box(a) box(a) = box(b) box(b) = tempSwap y = Asc(Mid(strData, x, 1)) Xor box((box(a) + box(b)) Mod 256) encryptedData = encryptedData &amp; LCase(Right(&quot;0&quot; &amp; Hex(y), 2)) Next RC4 = encryptedDataEnd Functionmsgbox &quot;Do you know VBScript?&quot;msgbox &quot;VBScript (&quot;&quot;Microsoft Visual Basic Scripting Edition&quot;&quot;) is a deprecated Active Scripting language developed by Microsoft that is modeled on Visual Basic.&quot;msgbox &quot;It allows Microsoft Windows system administrators to generate powerful tools for managing computers without error handling and with subroutines and other advanced programming constructs. It can give the user complete control over many aspects of their computing environment.&quot;msgbox &quot;Interestingly, although VBScript has long since been deprecated, you can still run VBScript scripts on the latest versions of Windows 11 systems.&quot;msgbox &quot;A VBScript script must be executed within a host environment, of which there are several provided with Microsoft Windows, including: Windows Script Host (WSH), Internet Explorer (IE), and Internet Information Services (IIS).&quot;msgbox &quot;For .vbs files, the host is Windows Script Host (WSH), aka wscript.exe/cscript.exe program in your system.&quot;msgbox &quot;If you can not stop a VBScript from running (e.g. a dead loop), go to the task manager and kill wscript.exe/cscript.exe.&quot;msgbox &quot;cscript and wscript are executables for the scripting host that are used to run the scripts. cscript and wscript are both interpreters to run VBScript (and other scripting languages like JScript) on the Windows platform.&quot;msgbox &quot;cscript is for console applications and wscript is for Windows applications. It has something to do with STDIN, STDOUT and STDERR.&quot;msgbox &quot;OK! Now, let us begin our journey.&quot;key = InputBox(&quot;Enter the key:&quot;, &quot;CTF Challenge&quot;)if (key = False) then wscript.quitif (len(key)&lt;&gt;6) then wscript.echo &quot;wrong key length!&quot; wscript.quitend ifIf (MD5(key) = md5_key) Then wscript.echo &quot;You get the key!Move to next challenge.&quot;Else wscript.echo &quot;Wrong key!Try again!&quot; wscript.quitEnd IfuserInput = InputBox(&quot;Enter the flag:&quot;, &quot;CTF Challenge&quot;)if (userInput = False) then wscript.quitif (len(userInput)&lt;&gt;44) then wscript.echo &quot;wrong!&quot; wscript.quitend ifbox = RC4_init(key)encryptedInput = RC4(box, userInput)If (encryptedInput = enc_flag) Then MsgBox &quot;Congratulations! You have learned VBS!&quot;Else MsgBox &quot;Wrong flag. Try again.&quot;End Ifwscript.echo &quot;bye!&quot;&#x27; enc_flag = 0x59fc6b263c3d0fcbc331ade699e62d3473bbf85522d588e3423e6c751ca091528a3c0186e460483917192c14&#x27; md5(key) = baacc7ffa8232d28f814bb14c428798b RC4加密，key只有md5后的哈希，用hashcat爆破拿到key 解密： 123456789101112131415161718192021222324# ./hashcat.exe -a 3 -m 0 -d 1 &quot;baacc7ffa8232d28f814bb14c428798b&quot; ?a?a?a?a?a?adef rc4_decrypt(key, ciphertext): S = list(range(256)) j = 0 out = [] for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] i = j = 0 for char in ciphertext: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] out.append(char ^ S[(S[i] + S[j]) % 256]) return bytes(out)key = &#x27;H&amp;NKEY&#x27;ciphertext = bytes.fromhex(&#x27;59fc6b263c3d0fcbc331ade699e62d3473bbf85522d588e3423e6c751ca091528a3c0186e460483917192c14&#x27;)plaintext = rc4_decrypt(key.encode(), ciphertext)print(plaintext) H&amp;NCTF{VBS_1s_@_s0_7unny_an4_pow3rfu1_t00l!} hnwanna找到主函数，申清加密逻辑： 写解密代码： 12345678910111213141516171819202122232425#include &lt;cstdio&gt;void a(char* input, int shift)&#123; char text[19]; printf(&quot;H&amp;NCTF&#123;&quot;); for(int i = 0; i &lt; 18; i++) &#123; if(input[i] &gt;= &#x27;a&#x27; &amp;&amp; input[i] &lt;= &#x27;z&#x27;) text[i] = ((char)(((int)(input[i] - &#x27;a&#x27;) + shift) % 26 + 97)); else text[i] += input[i]; printf(&quot;%c&quot;, text[i]); &#125; printf(&quot;&#125;&quot;);&#125;int main()&#123; char enc[] = &quot;justaeasyunitygame&quot;; int key = 5; a(enc, key); return 0;&#125; H&amp;NCTF{ozxyfjfxdzsnydlfrj} DO YOU KNOW SWDD?在异常处发现有SMC，找到SMC函数： 写IDC脚本解密： 得到加密函数： 解密： 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;int main()&#123; char enc[] = &quot;S_VYFO_CGNN_GRKD_KLYED_IYE&quot;; int v4 = 10; printf(&quot;H&amp;NCTF&#123;&quot;); for(int i = 0; enc[i]; ++i) &#123; if(enc[i] &gt;= 65 &amp;&amp; enc[i] &lt;= 90) enc[i] = (enc[i] - v4 + 65) % 26 + 65; printf(&quot;%c&quot;, enc[i]); &#125; printf(&quot;&#125;&quot;); return 0;&#125;/*#include &lt;idc.idc&gt;static main()&#123; auto addr = 0x00417001; auto i = 0; auto j = 0; auto v5 = &quot;swdd&quot;; for(j = addr; j &lt; 0x0041815B; j++) PatchByte(j, Byte(j) ^ 4);&#125;*/ H&amp;NCTF{I_LOVE_SWDD_WHAT_ABOUT_YOU} 最喜欢的逆向题自己看图： H&amp;NCTF{Do_Y0u_like_F5_1n_Rev}","categories":[{"name":"比赛WP","slug":"比赛WP","permalink":"https://pinguw.github.io/categories/%E6%AF%94%E8%B5%9BWP/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://pinguw.github.io/tags/WriteUp/"}]},{"title":"MRCTF2020 VirtualTree（花指令+动态调试）","slug":"Reverse/VirtualTree","date":"2024-04-10T14:27:36.000Z","updated":"2024-04-11T13:11:36.569Z","comments":true,"path":"2024/04/10/Reverse/VirtualTree/","permalink":"https://pinguw.github.io/2024/04/10/Reverse/VirtualTree/","excerpt":"","text":"[MRCTF2020]VirtualTree（花指令+动态调试）32位无壳，放进IDA里，main函数很清晰， 试着恢复一下符号表： 看一下key的调用，找到更改key值的函数， 结合题目，可以看出这是一个二叉树，搞一个结构体： 回头看第一个加密函数： 就是把key中的数据根input一个一个异或，比较简单， 把input搞成0，动调可以搞到key的数据 1key = &quot;MLGPOKFCJENIHDBA&quot; 再分析enc2:，有花指令，比较容易去掉： 去掉后里面的加密函数是这样： 逆向这个函数解密后发现根本解不出来，动调一下试试： 动调后发现这些函数全被更改了，汇编是这样的： call的那些函数是对input执行了一些简单的更改。 汇编： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990.text:004216F0 push ebp.text:004216F1 mov ebp, esp.text:004216F3 push 0Ah.text:004216F5 push 0.text:004216F7 mov eax, offset func_add.text:004216FC call eax ; loc_421510 //input[0] += 10.text:004216FC.text:004216FE add esp, 8.text:00421701 push 2.text:00421703 push 1.text:00421705 mov eax, offset func_xor.text:0042170A call eax ; loc_421510 //input[1] ^= input[2].text:0042170A.text:0042170C add esp, 8.text:0042170F push 7.text:00421711 push 2.text:00421713 mov eax, offset func_add.text:00421718 call eax ; loc_421510 //input[2] += 7.text:00421718.text:0042171A add esp, 8.text:0042171D push 7.text:0042171F push 3.text:00421721 mov eax, offset func_sub.text:00421726 call eax ; loc_421510 //input[3] = abs(input[3] - input[7]).text:00421726.text:00421728 add esp, 8.text:0042172B push 5.text:0042172D push 4.text:0042172F mov eax, offset func_xor.text:00421734 call eax ; loc_421510 //input[4] ^= input[5].text:00421734.text:00421736 add esp, 8.text:00421739 push 1.text:0042173B push 6.text:0042173D mov eax, offset func_sub.text:00421742 call eax ; loc_421510 //input[6] = abs(input[6] - input[1]).text:00421742.text:00421744 add esp, 8.text:00421747 push 3.text:00421749 push 7.text:0042174B mov eax, offset func_add.text:00421750 call eax ; loc_421510 //input[7] += 3.text:00421750.text:00421752 add esp, 8.text:00421755 push 7.text:00421757 push 8.text:00421759 mov eax, offset func_xor.text:0042175E call eax ; loc_421510 //input[8] ^= input[7].text:0042175E.text:00421760 add esp, 8.text:00421763 push 8.text:00421765 push 9.text:00421767 mov eax, offset func_sub.text:0042176C call eax ; loc_421510 //input[9] = abs(input[9] - input[8]).text:0042176C.text:0042176E add esp, 8.text:00421771 push 7.text:00421773 push 0Ah.text:00421775 mov eax, offset func_sub.text:0042177A call eax ; loc_421510 //input[10] = abs(input[10] - input[7]).text:0042177A.text:0042177C add esp, 8.text:0042177F push 0Ch.text:00421781 push 0Bh.text:00421783 mov eax, offset func_xor.text:00421788 call eax ; loc_421510 //input[11] ^= input[12].text:00421788.text:0042178A add esp, 8.text:0042178D push 2.text:0042178F push 0Ch.text:00421791 mov eax, offset func_sub.text:00421796 call eax ; loc_421510 //input[12] = abs(input[12] - input[2]).text:00421796.text:00421798 add esp, 8.text:0042179B push 0Fh.text:0042179D push 0Eh.text:0042179F mov eax, offset func_xor.text:004217A4 call eax ; loc_421510 //input[14] ^= input[15].text:004217A4.text:004217A6 add esp, 8.text:004217A9 push 2.text:004217AB push 0Fh.text:004217AD mov eax, offset func_add.text:004217B2 call eax ; loc_421510 //input[15] += 2.text:004217B2.text:004217B4 add esp, 8.text:004217B7 nop.text:004217B8 nop.text:004217B9 pop ebp.text:004217BA retn 写解密代码： 12345678910111213141516171819202122232425262728293031input = [0x17, 0x63, 0x77, 0x03, 0x52, 0x2E, 0x4A, 0x28, 0x52, 0x1B, 0x17, 0x12, 0x3A, 0x0A, 0x6C, 0x62]def add(a, b): input[a] -= bdef xor(a, b): input[a] ^= input[b]def sub(a, b): # maybe_input1.append(input[a] + input[b]) # maybe_input2.append(input[b] - input[a]) input[a] = abs(input[a] - input[b]) # 因为abs有两种可能性，全取这种可能得到的flag最正常key = &quot;MLGPOKFCJENIHDBA&quot;opcode = [1, 2, 1, 3, 2, 3, 1, 2, 3, 3, 2, 3, 2, 1] # 1表示加密中的add, 2表示xor, 3表示suba1 = [0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 14, 15] # 第一个参数a2 = [10, 2, 7, 7, 5, 1, 3, 7, 8, 7, 12, 2, 15, 2] # 第二个参数for i in range(13, -1, -1): if opcode[i] == 1: add(a1[i], a2[i]) elif opcode[i] == 2: xor(a1[i], a2[i]) elif opcode[i] == 3: sub(a1[i], a2[i])for i in range(16): input[i] ^= ord(key[i])for i in input: print(chr(i), end = &#x27;&#x27;) 得到flag： MRCTF{@_7r3e_f0r_fuNN!}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://pinguw.github.io/categories/Reverse/"}],"tags":[{"name":"刷题记录","slug":"刷题记录","permalink":"https://pinguw.github.io/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"去OLLVM平坦化([SUCTF2019]hardCPP)","slug":"Reverse/LLVM","date":"2024-03-26T14:46:39.000Z","updated":"2024-04-11T13:53:32.020Z","comments":true,"path":"2024/03/26/Reverse/LLVM/","permalink":"https://pinguw.github.io/2024/03/26/Reverse/LLVM/","excerpt":"","text":"去OLLVM平坦化([SUCTF2019]hardCPP)用ida打开是这样 十分有十二分的平坦化痕迹， 上次强网杯遇到过，但是因为当时没装好环境，deflat.py跑不出来，遗憾放弃。 这次又碰见不想再回避，打开这个网址把脚本装下来，https://github.com/Pure-T/deflat，看readme，要先装一个angr库（这个库在做VM虚拟机类题，写解析器脚本的时候也会很有用，以后可能再写） 1pip install angr 下载时间可能会有点长， 官方说的是用8.19.4.5版本，实际较新版本依然可用， 装好后用以下指令去平坦化： 12python deflat.py hardCpp 0x4007E0 #python + deflat.py + 文件名 + 起始地址(基本就是main函数的地址) 然而出错： 回看readme， 下载那个graph.py然后改名为am_graph.py ，将其与deflat.py放在同一目录下， 再次运行相同命令： 12python deflat.py hardCpp 0x4007E0 #python + deflat.py + 文件名 + 起始地址(基本就是main函数的地址) 期间可能会出现大量类似警告： 不要害怕，只要最后是这样就好： 将recovered的文件再放进ida里面看： 成功！ 下面就是逆向环节了也有部分去平坦化操作 首先排除上面这两个循环有用， 看到这一坨函数不要怕，其实就是c++里面的奇奇怪怪的东西（好像叫lambda表达式），来看看他们到底是干嘛的， 在对各函数分析的过程中发现在0x401310、0x4014E0和0x4016C0依然有平坦化，再跑脚本去一下， 1python deflat.py hardCpp_recovered 0x401310 0x401310： 再跑一遍 1python deflat.py hardCpp_recovered_recovered 0x4016C0 0x4016C0： 再跑一遍： 1python deflat.py hardCpp_recovered_recovered_recovered 0x4014E0 0x4014E0： 得到hardCPP_recovered_recovered_recovered_recovered 这次再放进ida并改名： 接下来就是搞清func1、func2、func3的功能： 其中两个就是是return第二个数据，另一个是add， 把这几个函数简化成表达式： 是不是已经非常清晰了！ 整理一下： 1v18 = (3 * (18 ^ input[i - 1 + v21]) + 2) ^ ((v21 ^ input[i]) + (input[i - 1 + v21] % 7)) 从前面看出：v21大概是0 （真的是大概，当时我也不太确定） 然后等式左边的v18就是enc[i]那么这个算法显然可逆： 把函数开头的md5解密一下： 那么flag（input）的第一位是‘#’ 好了可以写解密代码了： 12345678910enc = [0xF3, 0x2E, 0x18, 0x36, 0xE1, 0x4C, 0x22, 0xD1, 0xF9, 0x8C, 0x40, 0x76, 0xF4, 0x0E, 0x00, 0x05, 0xA3, 0x90, 0x0E, 0xA5]input = &#x27;#&#x27;k = len(input)for j in range(len(enc)): input += chr(((enc[j] ^ ((ord(input[j]) ^ 18) * 3 + 2)) - (ord(input[j]) % 7)) &amp; 0xff)print(input) flag： flag{mY-CurR1ed_Fns}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://pinguw.github.io/categories/Reverse/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"https://pinguw.github.io/tags/Re%E5%88%86%E4%BA%AB/"},{"name":"刷题记录","slug":"刷题记录","permalink":"https://pinguw.github.io/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"浅谈VM虚拟机","slug":"Reverse/aboutvm","date":"2024-03-26T14:43:22.000Z","updated":"2024-04-14T08:09:33.551Z","comments":true,"path":"2024/03/26/Reverse/aboutvm/","permalink":"https://pinguw.github.io/2024/03/26/Reverse/aboutvm/","excerpt":"","text":"浅谈VM虚拟机1. 什么是虚拟机？ 虚拟机：自己定义一套指令，在程序中能有一套函数和结构解释自己定义的指令并执行功能。 查一下维基百科 虚拟机（英语：virtual machine），在计算机科学中的体系结构里，是指一种特殊的软件，可以在计算机平台和终端用户之间创建一种环境，而终端用户则是基于虚拟机这个软件所创建的环境来操作其它软件。虚拟机（VM）是计算机系统的仿真器，通过软件模拟具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统，能提供物理计算机的功能。 有不同种类的虚拟机，每种虚拟机具有不同的功能： 系统虚拟机（也称为全虚拟化虚拟机）可代替物理计算机。它提供了运行整个操作系统所需的功能。虚拟机监视器（hypervisor）共享和管理硬件，从而允许有相互隔离但存在于同一物理机器上的多个环境。现代虚拟机监视器使用虚拟化专用硬件（主要是主机CPU）来进行硬件辅助虚拟化。 程序虚拟机 被设计用来在与平台无关的环境中执行计算机程序。 而我们CTF中遇到的虚拟机一般是这种： vm（虚拟机保护）是一种基于虚拟机的代码保护技术。他将基于x86汇编系统中的可执行代码转换为字节码指令系统的代码。来达到不被轻易篡改和逆向的目的。 2. 虚拟机的运行原理要搞清虚拟机的运行原理，最好的方法是手搓一个虚拟机出来： 一般虚拟机分为基于寄存器的虚拟机和基于栈的虚拟机，通过数据存储处理的方式区分，二者的区别可以看这里 栈式虚拟机和寄存器式虚拟机？ 这里先写一个简单的寄存器虚拟机， 实现虚拟机时，要做好这么几个步骤： 寄存器虚拟机需要初始化好栈空间和寄存器空间 定义一套opcode 实现opcode功能的模块 定义opcode和寄存器： 1234567891011121314enum regist&#123; R1 = 0xe1, R2 = 0xe2, R3 = 0xe3,&#125;;enum opcodes&#123; MOV = 0xf1, XOR = 0xf2, RET = 0xf4, READ = 0xf5,&#125;; 定义vm相关变量： 1234567891011121314typedef struct&#123; unsigned char opcode; void (*handle)(void*); //handler执行器&#125;vm_opcode;typedef struct vm_cpus&#123; int r1; int r2; int r3; unsigned char* eip; //指向opcode的指针 vm_opcode op_list[OPCODE_N]; //opcode列表，存储opcode和其对应的操作函数&#125;vm_cpu; 初始化vm各项数据，并使opcode关联handler功能函数 12345678910111213141516171819void vm_init(vm_cpu* cpu)&#123; cpu-&gt;r1 = 0; cpu-&gt;r2 = 0; cpu-&gt;r3 = 0; cpu-&gt;eip = (unsigned char*)vm_code; cpu-&gt;op_list[0].opcode = 0xf1; cpu-&gt;op_list[0].handle = (void (*)(void*))mov; //0xf1对应mov cpu-&gt;op_list[1].opcode = 0xf2; cpu-&gt;op_list[1].handle = (void (*)(void*))xor1; //0xf2对应xor cpu-&gt;op_list[2].opcode = 0xf5; cpu-&gt;op_list[2].handle = (void (*)(void*))read1; //0xf1对应read vm_stack = (char*)malloc(0x512); memset(vm_stack, 0, 0x512); //开辟栈空间&#125; vm启动函数： 123456void vm_start(vm_cpu* cpu)&#123; cpu-&gt;eip = (unsigned char*)vm_code; while((*cpu-&gt;eip) != RET) //持续执行opcode直到ret vm_dispatcher(cpu);&#125; 执行器： 123456789void vm_dispatcher(vm_cpu* cpu)&#123; for(int i = 0; i &lt; OPCODE_N; i++) if(*cpu-&gt;eip == cpu-&gt;op_list[i].opcode) &#123; cpu-&gt;op_list[i].handle(cpu); break; &#125;&#125; 再写出opcode： 123456789101112131415161718192021222324252627282930unsigned char vm_code[] = &#123; 0xf5, 0xf1,0xe1,0x0,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x0,0x00,0x00,0x00, 0xf1,0xe1,0x1,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x1,0x00,0x00,0x00, 0xf1,0xe1,0x2,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x2,0x00,0x00,0x00, 0xf1,0xe1,0x3,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x3,0x00,0x00,0x00, 0xf1,0xe1,0x4,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x4,0x00,0x00,0x00, 0xf1,0xe1,0x5,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x5,0x00,0x00,0x00, 0xf1,0xe1,0x6,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x6,0x00,0x00,0x00, 0xf1,0xe1,0x7,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x7,0x00,0x00,0x00, 0xf1,0xe1,0x8,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x8,0x00,0x00,0x00, 0xf1,0xe1,0x9,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x9,0x00,0x00,0x00, 0xf1,0xe1,0xa,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xa,0x00,0x00,0x00, 0xf1,0xe1,0xb,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xb,0x00,0x00,0x00, 0xf1,0xe1,0xc,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xc,0x00,0x00,0x00, 0xf1,0xe1,0xd,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xd,0x00,0x00,0x00, 0xf1,0xe1,0xe,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xe,0x00,0x00,0x00, 0xf1,0xe1,0xf,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xf,0x00,0x00,0x00, 0xf1,0xe1,0x10,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x10,0x00,0x00,0x00, 0xf1,0xe1,0x11,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x11,0x00,0x00,0x00, 0xf1,0xe1,0x12,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x12,0x00,0x00,0x00, 0xf1,0xe1,0x13,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x13,0x00,0x00,0x00, 0xf1,0xe1,0x14,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x14,0x00,0x00,0x00, 0xf1,0xe1,0x15,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x15,0x00,0x00,0x00, 0xf1,0xe1,0x16,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x16,0x00,0x00,0x00, 0xf1,0xe1,0x17,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x17,0x00,0x00,0x00, 0xf1,0xe1,0x18,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x18,0x00,0x00,0x00, 0xf1,0xe1,0x19,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x19,0x00,0x00,0x00, 0xf4&#125;; 寄存器虚拟机完成。 3. 给个实例，出个小题上面的虚拟机大概实现的就是这个过程 1234567call read1MOV R1,flag[i]XOR R1 0x12MOV [OFFEST],R1; //循环len(flag)次ret 也就是实现了 12for(int i = 0; i &lt; strlen(flag); i++) flag[i] ^= 0x12; 的功能。 把源码放在这： maybeVM 4. 如何破解VM虚拟机保护类题目 解题一般步骤： 分析VM结构-&gt;分析opcode-&gt;编写parser-&gt;re算法 VM结构常见类型： 基于栈、基于队列、基于信号量 opcode： 与VM数据结构对应的指令 ：push pop 运算指令：add、sub、mul等 示例1链接：[NewStarCTF 2023 公开赛道]茶 用来简单了解VM原理 ——by me 示例2链接：[watevrCTF 2019]Repyc——WriteUp pyc+混淆+VM虚拟机 ——by me","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://pinguw.github.io/categories/Reverse/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"https://pinguw.github.io/tags/Re%E5%88%86%E4%BA%AB/"},{"name":"刷题记录","slug":"刷题记录","permalink":"https://pinguw.github.io/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]}],"categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://pinguw.github.io/categories/Reverse/"},{"name":"比赛WP","slug":"比赛WP","permalink":"https://pinguw.github.io/categories/%E6%AF%94%E8%B5%9BWP/"}],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"https://pinguw.github.io/tags/Re%E5%88%86%E4%BA%AB/"},{"name":"WriteUp","slug":"WriteUp","permalink":"https://pinguw.github.io/tags/WriteUp/"},{"name":"刷题记录","slug":"刷题记录","permalink":"https://pinguw.github.io/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]}