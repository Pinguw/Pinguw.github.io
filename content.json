{"meta":{"title":"Pinguw's Blog","subtitle":"","description":"","author":"Pinguw","url":"http://example.com","root":"/"},"pages":[{"title":"文章归档","date":"2024-03-15T14:42:47.866Z","updated":"2024-03-15T14:35:20.532Z","comments":true,"path":"archives.html","permalink":"http://example.com/archives.html","excerpt":"","text":""}],"posts":[{"title":"去LLVM平坦化([SUCTF2019]hardCPP)","slug":"LLVM-1","date":"2024-03-18T16:00:00.000Z","updated":"2024-03-19T13:36:42.114Z","comments":true,"path":"2024/03/19/LLVM-1/","permalink":"http://example.com/2024/03/19/LLVM-1/","excerpt":"","text":"去LLVM平坦化([SUCTF2019]hardCPP)用ida打开是这样 十分有十二分的LLVM平坦化痕迹， 上次强网杯遇到过，但是因为当时没装好环境，deflat.py跑不出来，遗憾放弃。 这次又碰见不想再回避，打开这个网址把脚本装下来，https://github.com/Pure-T/deflat，看readme，要先装一个angr库（这个库在做VM虚拟机类题，写解析器脚本的时候也会很有用，以后可能再写） 1pip install angr 下载时间可能会有点长， 官方说的是用8.19.4.5版本，实际较新版本依然可用， 装好后用以下指令去平坦化： 12python deflat.py hardCpp 0x4007E0 #python + deflat.py + 文件名 + 起始地址(基本就是main函数的地址) 然而出错： 回看readme， 下载那个graph.py然后改名为am_graph.py ，将其与deflat.py放在同一目录下， 再次运行相同命令： 12python deflat.py hardCpp 0x4007E0 #python + deflat.py + 文件名 + 起始地址(基本就是main函数的地址) 期间可能会出现大量类似警告： 不要害怕，只要最后是这样就好： 将recovered的文件再放进ida里面看： 成功！ 下面就是逆向环节了也有部分去平坦化操作 首先排除这俩循环有用， 看到这一坨函数不要怕，其实就是c++里面的奇奇怪怪的东西（好像叫lambda表达式），来看看他们到底是干嘛的， 在对各函数分析的过程中发现在0x401310、0x4014E0和0x4016C0依然有平坦化，再跑脚本去一下， 1python deflat.py hardCpp_recovered 0x401310 0x401310： 再跑一遍 1python deflat.py hardCpp_recovered_recovered 0x4016C0 0x4016C0： 再跑一遍： 1python deflat.py hardCpp_recovered_recovered_recovered 0x4014E0 0x4014E0： 得到hardCPP_recovered_recovered_recovered_recovered 这次再放进ida并改名： 接下来就是搞清func1、func2、func3的功能： 其中两个就是是return第二个数据，另一个是add， 把这几个函数简化成表达式： 是不是已经非常清晰了！ 整理一下： 1v18 = (3 * (18 ^ input[i - 1 + v21]) + 2) ^ ((v21 ^ input[i]) + (input[i - 1 + v21] % 7)) 从前面看出：v21大概是0 （真的是大概，当时我也不太确定） 然后等式左边的v18就是enc[i]那么这个算法显然可逆： 把函数开头的md5解密一下： 那么flag（input）的第一位是‘#’ 好了可以写解密代码了： 12345678910enc = [0xF3, 0x2E, 0x18, 0x36, 0xE1, 0x4C, 0x22, 0xD1, 0xF9, 0x8C, 0x40, 0x76, 0xF4, 0x0E, 0x00, 0x05, 0xA3, 0x90, 0x0E, 0xA5]input = &#x27;#&#x27;k = len(input)for j in range(len(enc)): input += chr(((enc[j] ^ ((ord(input[j]) ^ 18) * 3 + 2)) - (ord(input[j]) % 7)) &amp; 0xff)print(input) flag： flag{mY-CurR1ed_Fns}","categories":[],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"}]},{"title":"去LLVM平坦化([SUCTF2019]hardCPP)","slug":"LLVM","date":"2024-03-18T16:00:00.000Z","updated":"2024-03-19T13:33:55.608Z","comments":true,"path":"2024/03/19/LLVM/","permalink":"http://example.com/2024/03/19/LLVM/","excerpt":"","text":"去LLVM平坦化([SUCTF2019]hardCPP)用ida打开是这样 十分有十二分的LLVM平坦化痕迹， 上次强网杯遇到过，但是因为当时没装好环境，deflat.py跑不出来，遗憾放弃。 这次又碰见不想再回避，打开这个网址把脚本装下来，https://github.com/Pure-T/deflat，看readme，要先装一个angr库（这个库在做VM虚拟机类题，写解析器脚本的时候也会很有用，以后可能再写） 1pip install angr 下载时间可能会有点长， 官方说的是用8.19.4.5版本，实际较新版本依然可用， 装好后用以下指令去平坦化： 12python deflat.py hardCpp 0x4007E0 #python + deflat.py + 文件名 + 起始地址(基本就是main函数的地址) 然而出错： 回看readme， 下载那个graph.py然后改名为am_graph.py ，将其与deflat.py放在同一目录下， 再次运行相同命令： 12python deflat.py hardCpp 0x4007E0 #python + deflat.py + 文件名 + 起始地址(基本就是main函数的地址) 期间可能会出现大量类似警告： 不要害怕，只要最后是这样就好： 将recovered的文件再放进ida里面看： 成功！ 下面就是逆向环节了也有部分去平坦化操作 首先排除这俩循环有用， 看到这一坨函数不要怕，其实就是c++里面的奇奇怪怪的东西（好像叫lambda表达式），来看看他们到底是干嘛的， 在对各函数分析的过程中发现在0x401310、0x4014E0和0x4016C0依然有平坦化，再跑脚本去一下， 1python deflat.py hardCpp_recovered 0x401310 0x401310： 再跑一遍 1python deflat.py hardCpp_recovered_recovered 0x4016C0 0x4016C0： 再跑一遍： 1python deflat.py hardCpp_recovered_recovered_recovered 0x4014E0 0x4014E0： 得到hardCPP_recovered_recovered_recovered_recovered 这次再放进ida并改名： 接下来就是搞清func1、func2、func3的功能： 其中两个就是是return第二个数据，另一个是add， 把这几个函数简化成表达式： 是不是已经非常清晰了！ 整理一下： 1v18 = (3 * (18 ^ input[i - 1 + v21]) + 2) ^ ((v21 ^ input[i]) + (input[i - 1 + v21] % 7)) 从前面看出：v21大概是0 （真的是大概，当时我也不太确定） 然后等式左边的v18就是enc[i]那么这个算法显然可逆： 把函数开头的md5解密一下： 那么flag（input）的第一位是‘#’ 好了可以写解密代码了： 12345678910enc = [0xF3, 0x2E, 0x18, 0x36, 0xE1, 0x4C, 0x22, 0xD1, 0xF9, 0x8C, 0x40, 0x76, 0xF4, 0x0E, 0x00, 0x05, 0xA3, 0x90, 0x0E, 0xA5]input = &#x27;#&#x27;k = len(input)for j in range(len(enc)): input += chr(((enc[j] ^ ((ord(input[j]) ^ 18) * 3 + 2)) - (ord(input[j]) % 7)) &amp; 0xff)print(input) flag： flag{mY-CurR1ed_Fns}","categories":[],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"}]},{"title":"浅谈VM虚拟机","slug":"About_VM","date":"2024-03-11T16:00:00.000Z","updated":"2024-03-19T13:05:43.535Z","comments":true,"path":"2024/03/12/About_VM/","permalink":"http://example.com/2024/03/12/About_VM/","excerpt":"","text":"浅谈VM虚拟机1. 什么是虚拟机？ 虚拟机：自己定义一套指令，在程序中能有一套函数和结构解释自己定义的指令并执行功能。 查一下维基百科 虚拟机（英语：virtual machine），在计算机科学中的体系结构里，是指一种特殊的软件，可以在计算机平台和终端用户之间创建一种环境，而终端用户则是基于虚拟机这个软件所创建的环境来操作其它软件。虚拟机（VM）是计算机系统的仿真器，通过软件模拟具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统，能提供物理计算机的功能。 有不同种类的虚拟机，每种虚拟机具有不同的功能： 系统虚拟机（也称为全虚拟化虚拟机）可代替物理计算机。它提供了运行整个操作系统所需的功能。虚拟机监视器（hypervisor）共享和管理硬件，从而允许有相互隔离但存在于同一物理机器上的多个环境。现代虚拟机监视器使用虚拟化专用硬件（主要是主机CPU）来进行硬件辅助虚拟化。 程序虚拟机 被设计用来在与平台无关的环境中执行计算机程序。 而我们CTF中遇到的虚拟机一般是这种： vm（虚拟机保护）是一种基于虚拟机的代码保护技术。他将基于x86汇编系统中的可执行代码转换为字节码指令系统的代码。来达到不被轻易篡改和逆向的目的。 2. 虚拟机的运行原理要搞清虚拟机的运行原理，最好的方法是手搓一个虚拟机出来： 一般虚拟机分为基于寄存器的虚拟机和基于栈的虚拟机，通过数据存储处理的方式区分，二者的区别可以看这里 栈式虚拟机和寄存器式虚拟机？ 这里先写一个简单的寄存器虚拟机， 实现虚拟机时，要做好这么几个步骤： 寄存器虚拟机需要初始化好栈空间和寄存器空间 定义一套opcode 实现opcode功能的模块 定义opcode和寄存器： 1234567891011121314enum regist&#123; R1 = 0xe1, R2 = 0xe2, R3 = 0xe3,&#125;;enum opcodes&#123; MOV = 0xf1, XOR = 0xf2, RET = 0xf4, READ = 0xf5,&#125;; 定义vm相关变量： 1234567891011121314typedef struct&#123; unsigned char opcode; void (*handle)(void*); //handler执行器&#125;vm_opcode;typedef struct vm_cpus&#123; int r1; int r2; int r3; unsigned char* eip; //指向opcode的指针 vm_opcode op_list[OPCODE_N]; //opcode列表，存储opcode和其对应的操作函数&#125;vm_cpu; 初始化vm各项数据，并使opcode关联handler功能函数 12345678910111213141516171819void vm_init(vm_cpu* cpu)&#123; cpu-&gt;r1 = 0; cpu-&gt;r2 = 0; cpu-&gt;r3 = 0; cpu-&gt;eip = (unsigned char*)vm_code; cpu-&gt;op_list[0].opcode = 0xf1; cpu-&gt;op_list[0].handle = (void (*)(void*))mov; //0xf1对应mov cpu-&gt;op_list[1].opcode = 0xf2; cpu-&gt;op_list[1].handle = (void (*)(void*))xor1; //0xf2对应xor cpu-&gt;op_list[2].opcode = 0xf5; cpu-&gt;op_list[2].handle = (void (*)(void*))read1; //0xf1对应read vm_stack = (char*)malloc(0x512); memset(vm_stack, 0, 0x512); //开辟栈空间&#125; vm启动函数： 123456void vm_start(vm_cpu* cpu)&#123; cpu-&gt;eip = (unsigned char*)vm_code; while((*cpu-&gt;eip) != RET) //持续执行opcode直到ret vm_dispatcher(cpu);&#125; 执行器： 123456789void vm_dispatcher(vm_cpu* cpu)&#123; for(int i = 0; i &lt; OPCODE_N; i++) if(*cpu-&gt;eip == cpu-&gt;op_list[i].opcode) &#123; cpu-&gt;op_list[i].handle(cpu); break; &#125;&#125; 再写出opcode： 123456789101112131415161718192021222324252627282930unsigned char vm_code[] = &#123; 0xf5, 0xf1,0xe1,0x0,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x0,0x00,0x00,0x00, 0xf1,0xe1,0x1,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x1,0x00,0x00,0x00, 0xf1,0xe1,0x2,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x2,0x00,0x00,0x00, 0xf1,0xe1,0x3,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x3,0x00,0x00,0x00, 0xf1,0xe1,0x4,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x4,0x00,0x00,0x00, 0xf1,0xe1,0x5,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x5,0x00,0x00,0x00, 0xf1,0xe1,0x6,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x6,0x00,0x00,0x00, 0xf1,0xe1,0x7,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x7,0x00,0x00,0x00, 0xf1,0xe1,0x8,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x8,0x00,0x00,0x00, 0xf1,0xe1,0x9,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x9,0x00,0x00,0x00, 0xf1,0xe1,0xa,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xa,0x00,0x00,0x00, 0xf1,0xe1,0xb,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xb,0x00,0x00,0x00, 0xf1,0xe1,0xc,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xc,0x00,0x00,0x00, 0xf1,0xe1,0xd,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xd,0x00,0x00,0x00, 0xf1,0xe1,0xe,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xe,0x00,0x00,0x00, 0xf1,0xe1,0xf,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0xf,0x00,0x00,0x00, 0xf1,0xe1,0x10,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x10,0x00,0x00,0x00, 0xf1,0xe1,0x11,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x11,0x00,0x00,0x00, 0xf1,0xe1,0x12,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x12,0x00,0x00,0x00, 0xf1,0xe1,0x13,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x13,0x00,0x00,0x00, 0xf1,0xe1,0x14,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x14,0x00,0x00,0x00, 0xf1,0xe1,0x15,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x15,0x00,0x00,0x00, 0xf1,0xe1,0x16,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x16,0x00,0x00,0x00, 0xf1,0xe1,0x17,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x17,0x00,0x00,0x00, 0xf1,0xe1,0x18,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x18,0x00,0x00,0x00, 0xf1,0xe1,0x19,0x00,0x00,0x00, 0xf2, 0xf1,0xe4,OFFEST + 0x19,0x00,0x00,0x00, 0xf4&#125;; 寄存器虚拟机完成。 3. 给个实例，出个小题上面的虚拟机大概实现的就是这个过程 1234567call read1MOV R1,flag[i]XOR R1 0x12MOV [OFFEST],R1; //循环len(flag)次ret 也就是实现了 12for(int i = 0; i &lt; strlen(flag); i++) flag[i] ^= 0x12; 的功能。 把源码放在这： maybeVM 4. 如何破解VM虚拟机保护类题目 解题一般步骤： 分析VM结构-&gt;分析opcode-&gt;编写parser-&gt;re算法 VM结构常见类型： 基于栈、基于队列、基于信号量 opcode： 与VM数据结构对应的指令 ：push pop 运算指令：add、sub、mul等 示例1链接：[NewStarCTF 2023 公开赛道]茶 用来简单了解VM原理 示例2链接：[watevrCTF 2019]Repyc——WriteUp pyc+混淆+VM虚拟机","categories":[],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"}]}],"categories":[],"tags":[{"name":"Re分享","slug":"Re分享","permalink":"http://example.com/tags/Re%E5%88%86%E4%BA%AB/"}]}